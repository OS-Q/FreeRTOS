; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\queue.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\obj\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\bsp -I..\User\bsp\inc -I..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I.\RTE\_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\queue.crf ..\..\FreeRTOS\queue.c]
                          THUMB

                          AREA ||i.pcQueueGetName||, CODE, READONLY, ALIGN=2

                  pcQueueGetName PROC
;;;2672   
;;;2673   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2674   	{
;;;2675   	UBaseType_t ux;
;;;2676   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000002  2000              MOVS     r0,#0
;;;2677   
;;;2678   		/* Note there is nothing here to protect against another task adding or
;;;2679   		removing entries from the registry while it is being searched. */
;;;2680   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000004  2100              MOVS     r1,#0
000006  e00a              B        |L1.30|
                  |L1.8|
;;;2681   		{
;;;2682   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000008  4b07              LDR      r3,|L1.40|
00000a  eb0303c1          ADD      r3,r3,r1,LSL #3
00000e  685b              LDR      r3,[r3,#4]
000010  4293              CMP      r3,r2
000012  d103              BNE      |L1.28|
;;;2683   			{
;;;2684   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000014  4b04              LDR      r3,|L1.40|
000016  f8530031          LDR      r0,[r3,r1,LSL #3]
;;;2685   				break;
00001a  e002              B        |L1.34|
                  |L1.28|
00001c  1c49              ADDS     r1,r1,#1              ;2680
                  |L1.30|
00001e  2908              CMP      r1,#8                 ;2680
000020  d3f2              BCC      |L1.8|
                  |L1.34|
000022  bf00              NOP      
;;;2686   			}
;;;2687   			else
;;;2688   			{
;;;2689   				mtCOVERAGE_TEST_MARKER();
;;;2690   			}
;;;2691   		}
;;;2692   
;;;2693   		return pcReturn;
;;;2694   	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
000024  4770              BX       lr
;;;2695   
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      xQueueRegistry

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2148   
;;;2149   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b570              PUSH     {r4-r6,lr}
;;;2150   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2151   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000006  6c20              LDR      r0,[r4,#0x40]
000008  b170              CBZ      r0,|L2.40|
;;;2152   	{
;;;2153   		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  4401              ADD      r1,r1,r0
000010  60e1              STR      r1,[r4,#0xc]
;;;2154   		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000012  e9d41002          LDRD     r1,r0,[r4,#8]
000016  4288              CMP      r0,r1
000018  d301              BCC      |L2.30|
;;;2155   		{
;;;2156   			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
00001a  6821              LDR      r1,[r4,#0]
00001c  60e1              STR      r1,[r4,#0xc]
                  |L2.30|
;;;2157   		}
;;;2158   		else
;;;2159   		{
;;;2160   			mtCOVERAGE_TEST_MARKER();
;;;2161   		}
;;;2162   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00001e  4628              MOV      r0,r5
000020  6c22              LDR      r2,[r4,#0x40]
000022  68e1              LDR      r1,[r4,#0xc]
000024  f7fffffe          BL       __aeabi_memcpy
                  |L2.40|
;;;2163   	}
;;;2164   }
000028  bd70              POP      {r4-r6,pc}
;;;2165   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2069   
;;;2070   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2071   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;2072   BaseType_t xReturn = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;2073   UBaseType_t uxMessagesWaiting;
;;;2074   
;;;2075   	/* This function is called from a critical section. */
;;;2076   
;;;2077   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba6              LDR      r6,[r4,#0x38]
;;;2078   
;;;2079   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
000010  6c20              LDR      r0,[r4,#0x40]
000012  b948              CBNZ     r0,|L3.40|
;;;2080   	{
;;;2081   		#if ( configUSE_MUTEXES == 1 )
;;;2082   		{
;;;2083   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000014  6820              LDR      r0,[r4,#0]
000016  2800              CMP      r0,#0
000018  d12c              BNE      |L3.116|
;;;2084   			{
;;;2085   				/* The mutex is no longer being held. */
;;;2086   				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
00001a  68a0              LDR      r0,[r4,#8]
00001c  f7fffffe          BL       xTaskPriorityDisinherit
000020  4680              MOV      r8,r0
;;;2087   				pxQueue->u.xSemaphore.xMutexHolder = NULL;
000022  2000              MOVS     r0,#0
000024  60a0              STR      r0,[r4,#8]
000026  e025              B        |L3.116|
                  |L3.40|
;;;2088   			}
;;;2089   			else
;;;2090   			{
;;;2091   				mtCOVERAGE_TEST_MARKER();
;;;2092   			}
;;;2093   		}
;;;2094   		#endif /* configUSE_MUTEXES */
;;;2095   	}
;;;2096   	else if( xPosition == queueSEND_TO_BACK )
000028  b97d              CBNZ     r5,|L3.74|
;;;2097   	{
;;;2098   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
00002a  4639              MOV      r1,r7
00002c  6c22              LDR      r2,[r4,#0x40]
00002e  6860              LDR      r0,[r4,#4]
000030  f7fffffe          BL       __aeabi_memcpy
;;;2099   		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
000034  6c21              LDR      r1,[r4,#0x40]
000036  6860              LDR      r0,[r4,#4]
000038  4408              ADD      r0,r0,r1
00003a  6060              STR      r0,[r4,#4]
;;;2100   		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00003c  e9d40101          LDRD     r0,r1,[r4,#4]
000040  4288              CMP      r0,r1
000042  d317              BCC      |L3.116|
;;;2101   		{
;;;2102   			pxQueue->pcWriteTo = pxQueue->pcHead;
000044  6820              LDR      r0,[r4,#0]
000046  6060              STR      r0,[r4,#4]
000048  e014              B        |L3.116|
                  |L3.74|
;;;2103   		}
;;;2104   		else
;;;2105   		{
;;;2106   			mtCOVERAGE_TEST_MARKER();
;;;2107   		}
;;;2108   	}
;;;2109   	else
;;;2110   	{
;;;2111   		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
00004a  4639              MOV      r1,r7
00004c  6c22              LDR      r2,[r4,#0x40]
00004e  68e0              LDR      r0,[r4,#0xc]
000050  f7fffffe          BL       __aeabi_memcpy
;;;2112   		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
000054  6c21              LDR      r1,[r4,#0x40]
000056  68e0              LDR      r0,[r4,#0xc]
000058  1a41              SUBS     r1,r0,r1
00005a  60e1              STR      r1,[r4,#0xc]
;;;2113   		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00005c  6821              LDR      r1,[r4,#0]
00005e  68e0              LDR      r0,[r4,#0xc]
000060  4288              CMP      r0,r1
000062  d203              BCS      |L3.108|
;;;2114   		{
;;;2115   			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
000064  6c21              LDR      r1,[r4,#0x40]
000066  68a0              LDR      r0,[r4,#8]
000068  1a41              SUBS     r1,r0,r1
00006a  60e1              STR      r1,[r4,#0xc]
                  |L3.108|
;;;2116   		}
;;;2117   		else
;;;2118   		{
;;;2119   			mtCOVERAGE_TEST_MARKER();
;;;2120   		}
;;;2121   
;;;2122   		if( xPosition == queueOVERWRITE )
00006c  2d02              CMP      r5,#2
00006e  d101              BNE      |L3.116|
;;;2123   		{
;;;2124   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000070  b106              CBZ      r6,|L3.116|
;;;2125   			{
;;;2126   				/* An item is not being added but overwritten, so subtract
;;;2127   				one from the recorded number of items in the queue so when
;;;2128   				one is added again below the number of recorded items remains
;;;2129   				correct. */
;;;2130   				--uxMessagesWaiting;
000072  1e76              SUBS     r6,r6,#1
                  |L3.116|
;;;2131   			}
;;;2132   			else
;;;2133   			{
;;;2134   				mtCOVERAGE_TEST_MARKER();
;;;2135   			}
;;;2136   		}
;;;2137   		else
;;;2138   		{
;;;2139   			mtCOVERAGE_TEST_MARKER();
;;;2140   		}
;;;2141   	}
;;;2142   
;;;2143   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000074  1c70              ADDS     r0,r6,#1
000076  63a0              STR      r0,[r4,#0x38]
;;;2144   
;;;2145   	return xReturn;
000078  4640              MOV      r0,r8
;;;2146   }
00007a  e8bd81f0          POP      {r4-r8,pc}
;;;2147   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvGetDisinheritPriorityAfterTimeout||, CODE, READONLY, ALIGN=1

                  prvGetDisinheritPriorityAfterTimeout PROC
;;;2044   
;;;2045   	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
000000  4601              MOV      r1,r0
;;;2046   	{
;;;2047   	UBaseType_t uxHighestPriorityOfWaitingTasks;
;;;2048   
;;;2049   		/* If a task waiting for a mutex causes the mutex holder to inherit a
;;;2050   		priority, but the waiting task times out, then the holder should
;;;2051   		disinherit the priority - but only down to the highest priority of any
;;;2052   		other tasks that are waiting for the same mutex.  For this purpose,
;;;2053   		return the priority of the highest priority task that is waiting for the
;;;2054   		mutex. */
;;;2055   		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
000002  6a4a              LDR      r2,[r1,#0x24]
000004  b122              CBZ      r2,|L4.16|
;;;2056   		{
;;;2057   			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
000006  6b0a              LDR      r2,[r1,#0x30]
000008  6812              LDR      r2,[r2,#0]
00000a  f1c20005          RSB      r0,r2,#5
00000e  e000              B        |L4.18|
                  |L4.16|
;;;2058   		}
;;;2059   		else
;;;2060   		{
;;;2061   			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
000010  2000              MOVS     r0,#0
                  |L4.18|
;;;2062   		}
;;;2063   
;;;2064   		return uxHighestPriorityOfWaitingTasks;
;;;2065   	}
000012  4770              BX       lr
;;;2066   
                          ENDP


                          AREA ||i.prvInitialiseMutex||, CODE, READONLY, ALIGN=1

                  prvInitialiseMutex PROC
;;;472    
;;;473    	static void prvInitialiseMutex( Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;474    	{
000002  4604              MOV      r4,r0
;;;475    		if( pxNewQueue != NULL )
000004  b154              CBZ      r4,|L5.28|
;;;476    		{
;;;477    			/* The queue create function will set all the queue structure members
;;;478    			correctly for a generic queue, but this function is creating a
;;;479    			mutex.  Overwrite those members that need to be set differently -
;;;480    			in particular the information required for priority inheritance. */
;;;481    			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
000006  2000              MOVS     r0,#0
000008  60a0              STR      r0,[r4,#8]
;;;482    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000a  6020              STR      r0,[r4,#0]
;;;483    
;;;484    			/* In case this is a recursive mutex. */
;;;485    			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
00000c  2100              MOVS     r1,#0
00000e  60e1              STR      r1,[r4,#0xc]
;;;486    
;;;487    			traceCREATE_MUTEX( pxNewQueue );
;;;488    
;;;489    			/* Start with the semaphore in the expected state. */
;;;490    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
000010  2300              MOVS     r3,#0
000012  461a              MOV      r2,r3
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       xQueueGenericSend
                  |L5.28|
;;;491    		}
;;;492    		else
;;;493    		{
;;;494    			traceCREATE_MUTEX_FAILED();
;;;495    		}
;;;496    	}
00001c  bd10              POP      {r4,pc}
;;;497    
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;428    
;;;429    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;430    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9c06              LDR      r4,[sp,#0x18]
;;;431    	/* Remove compiler warnings about unused parameters should
;;;432    	configUSE_TRACE_FACILITY not be set to 1. */
;;;433    	( void ) ucQueueType;
;;;434    
;;;435    	if( uxItemSize == ( UBaseType_t ) 0 )
00000e  b90d              CBNZ     r5,|L6.20|
;;;436    	{
;;;437    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;438    		be set to NULL because NULL is used as a key to say the queue is used as
;;;439    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;440    		value that is known to be within the memory map. */
;;;441    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
000010  6024              STR      r4,[r4,#0]
000012  e000              B        |L6.22|
                  |L6.20|
;;;442    	}
;;;443    	else
;;;444    	{
;;;445    		/* Set the head to the start of the queue storage area. */
;;;446    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
000014  6027              STR      r7,[r4,#0]
                  |L6.22|
;;;447    	}
;;;448    
;;;449    	/* Initialise the queue members as described where the queue type is
;;;450    	defined. */
;;;451    	pxNewQueue->uxLength = uxQueueLength;
000016  63e6              STR      r6,[r4,#0x3c]
;;;452    	pxNewQueue->uxItemSize = uxItemSize;
000018  6425              STR      r5,[r4,#0x40]
;;;453    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xQueueGenericReset
;;;454    
;;;455    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;456    	{
;;;457    		pxNewQueue->ucQueueType = ucQueueType;
000022  f884804c          STRB     r8,[r4,#0x4c]
;;;458    	}
;;;459    	#endif /* configUSE_TRACE_FACILITY */
;;;460    
;;;461    	#if( configUSE_QUEUE_SETS == 1 )
;;;462    	{
;;;463    		pxNewQueue->pxQueueSetContainer = NULL;
;;;464    	}
;;;465    	#endif /* configUSE_QUEUE_SETS */
;;;466    
;;;467    	traceQUEUE_CREATE( pxNewQueue );
;;;468    }
000026  e8bd81f0          POP      {r4-r8,pc}
;;;469    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2286   
;;;2287   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2288   {
000002  4605              MOV      r5,r0
;;;2289   BaseType_t xReturn;
;;;2290   
;;;2291   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2292   	{
;;;2293   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  b908              CBNZ     r0,|L7.16|
;;;2294   		{
;;;2295   			xReturn = pdTRUE;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L7.18|
                  |L7.16|
;;;2296   		}
;;;2297   		else
;;;2298   		{
;;;2299   			xReturn = pdFALSE;
000010  2400              MOVS     r4,#0
                  |L7.18|
;;;2300   		}
;;;2301   	}
;;;2302   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;2303   
;;;2304   	return xReturn;
000016  4620              MOV      r0,r4
;;;2305   }
000018  bd70              POP      {r4-r6,pc}
;;;2306   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2326   
;;;2327   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2328   {
000002  4605              MOV      r5,r0
;;;2329   BaseType_t xReturn;
;;;2330   
;;;2331   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2332   	{
;;;2333   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba8              LDR      r0,[r5,#0x38]
00000a  6be9              LDR      r1,[r5,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L8.20|
;;;2334   		{
;;;2335   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L8.22|
                  |L8.20|
;;;2336   		}
;;;2337   		else
;;;2338   		{
;;;2339   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L8.22|
;;;2340   		}
;;;2341   	}
;;;2342   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2343   
;;;2344   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2345   }
00001c  bd70              POP      {r4-r6,pc}
;;;2346   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2166   
;;;2167   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;2168   {
000002  4604              MOV      r4,r0
;;;2169   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2170   
;;;2171   	/* The lock counts contains the number of extra data items placed or
;;;2172   	removed from the queue while the queue was locked.  When a queue is
;;;2173   	locked items can be added or removed, but the event lists cannot be
;;;2174   	updated. */
;;;2175   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2176   	{
;;;2177   		int8_t cTxLock = pxQueue->cTxLock;
000008  f9945045          LDRSB    r5,[r4,#0x45]
;;;2178   
;;;2179   		/* See if data was added to the queue while it was locked. */
;;;2180   		while( cTxLock > queueLOCKED_UNMODIFIED )
00000c  e010              B        |L9.48|
                  |L9.14|
;;;2181   		{
;;;2182   			/* Data was posted while the queue was locked.  Are any tasks
;;;2183   			blocked waiting for data to become available? */
;;;2184   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2185   			{
;;;2186   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2187   				{
;;;2188   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;2189   					{
;;;2190   						/* The queue is a member of a queue set, and posting to
;;;2191   						the queue set caused a higher priority task to unblock.
;;;2192   						A context switch is required. */
;;;2193   						vTaskMissedYield();
;;;2194   					}
;;;2195   					else
;;;2196   					{
;;;2197   						mtCOVERAGE_TEST_MARKER();
;;;2198   					}
;;;2199   				}
;;;2200   				else
;;;2201   				{
;;;2202   					/* Tasks that are removed from the event list will get
;;;2203   					added to the pending ready list as the scheduler is still
;;;2204   					suspended. */
;;;2205   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2206   					{
;;;2207   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2208   						{
;;;2209   							/* The task waiting has a higher priority so record that a
;;;2210   							context	switch is required. */
;;;2211   							vTaskMissedYield();
;;;2212   						}
;;;2213   						else
;;;2214   						{
;;;2215   							mtCOVERAGE_TEST_MARKER();
;;;2216   						}
;;;2217   					}
;;;2218   					else
;;;2219   					{
;;;2220   						break;
;;;2221   					}
;;;2222   				}
;;;2223   			}
;;;2224   			#else /* configUSE_QUEUE_SETS */
;;;2225   			{
;;;2226   				/* Tasks that are removed from the event list will get added to
;;;2227   				the pending ready list as the scheduler is still suspended. */
;;;2228   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00000e  6a60              LDR      r0,[r4,#0x24]
000010  b908              CBNZ     r0,|L9.22|
000012  2001              MOVS     r0,#1
000014  e000              B        |L9.24|
                  |L9.22|
000016  2000              MOVS     r0,#0
                  |L9.24|
000018  b938              CBNZ     r0,|L9.42|
;;;2229   				{
;;;2230   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00001a  f1040024          ADD      r0,r4,#0x24
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  b118              CBZ      r0,|L9.44|
;;;2231   					{
;;;2232   						/* The task waiting has a higher priority so record that
;;;2233   						a context switch is required. */
;;;2234   						vTaskMissedYield();
000024  f7fffffe          BL       vTaskMissedYield
000028  e000              B        |L9.44|
                  |L9.42|
;;;2235   					}
;;;2236   					else
;;;2237   					{
;;;2238   						mtCOVERAGE_TEST_MARKER();
;;;2239   					}
;;;2240   				}
;;;2241   				else
;;;2242   				{
;;;2243   					break;
00002a  e003              B        |L9.52|
                  |L9.44|
;;;2244   				}
;;;2245   			}
;;;2246   			#endif /* configUSE_QUEUE_SETS */
;;;2247   
;;;2248   			--cTxLock;
00002c  1e68              SUBS     r0,r5,#1
00002e  b245              SXTB     r5,r0
                  |L9.48|
000030  2d00              CMP      r5,#0                 ;2180
000032  dcec              BGT      |L9.14|
                  |L9.52|
000034  bf00              NOP                            ;2243
;;;2249   		}
;;;2250   
;;;2251   		pxQueue->cTxLock = queueUNLOCKED;
000036  20ff              MOVS     r0,#0xff
000038  f8840045          STRB     r0,[r4,#0x45]
;;;2252   	}
;;;2253   	taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;2254   
;;;2255   	/* Do the same for the Rx lock. */
;;;2256   	taskENTER_CRITICAL();
000040  f7fffffe          BL       vPortEnterCritical
;;;2257   	{
;;;2258   		int8_t cRxLock = pxQueue->cRxLock;
000044  f9945044          LDRSB    r5,[r4,#0x44]
;;;2259   
;;;2260   		while( cRxLock > queueLOCKED_UNMODIFIED )
000048  e010              B        |L9.108|
                  |L9.74|
;;;2261   		{
;;;2262   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00004a  6920              LDR      r0,[r4,#0x10]
00004c  b908              CBNZ     r0,|L9.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L9.84|
                  |L9.82|
000052  2000              MOVS     r0,#0
                  |L9.84|
000054  b948              CBNZ     r0,|L9.106|
;;;2263   			{
;;;2264   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000056  f1040010          ADD      r0,r4,#0x10
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  b108              CBZ      r0,|L9.100|
;;;2265   				{
;;;2266   					vTaskMissedYield();
000060  f7fffffe          BL       vTaskMissedYield
                  |L9.100|
;;;2267   				}
;;;2268   				else
;;;2269   				{
;;;2270   					mtCOVERAGE_TEST_MARKER();
;;;2271   				}
;;;2272   
;;;2273   				--cRxLock;
000064  1e68              SUBS     r0,r5,#1
000066  b245              SXTB     r5,r0
000068  e000              B        |L9.108|
                  |L9.106|
;;;2274   			}
;;;2275   			else
;;;2276   			{
;;;2277   				break;
00006a  e001              B        |L9.112|
                  |L9.108|
00006c  2d00              CMP      r5,#0                 ;2260
00006e  dcec              BGT      |L9.74|
                  |L9.112|
000070  bf00              NOP      
;;;2278   			}
;;;2279   		}
;;;2280   
;;;2281   		pxQueue->cRxLock = queueUNLOCKED;
000072  20ff              MOVS     r0,#0xff
000074  f8840044          STRB     r0,[r4,#0x44]
;;;2282   	}
;;;2283   	taskEXIT_CRITICAL();
000078  f7fffffe          BL       vPortExitCritical
;;;2284   }
00007c  bd70              POP      {r4-r6,pc}
;;;2285   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.ucQueueGetQueueType||, CODE, READONLY, ALIGN=1

                  ucQueueGetQueueType PROC
;;;2034   
;;;2035   	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2036   	{
;;;2037   		return ( ( Queue_t * ) xQueue )->ucQueueType;
000002  f891004c          LDRB     r0,[r1,#0x4c]
;;;2038   	}
000006  4770              BX       lr
;;;2039   
                          ENDP


                          AREA ||i.uxQueueGetQueueNumber||, CODE, READONLY, ALIGN=1

                  uxQueueGetQueueNumber PROC
;;;2014   
;;;2015   	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2016   	{
;;;2017   		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
000002  6c88              LDR      r0,[r1,#0x48]
;;;2018   	}
000004  4770              BX       lr
;;;2019   
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1925   
;;;1926   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1927   {
000002  4604              MOV      r4,r0
;;;1928   UBaseType_t uxReturn;
;;;1929   
;;;1930   	configASSERT( xQueue );
000004  b954              CBNZ     r4,|L12.28|
000006  bf00              NOP      
000008  2010              MOVS     r0,#0x10
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L12.26|
00001a  e7fe              B        |L12.26|
                  |L12.28|
;;;1931   
;;;1932   	taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;1933   	{
;;;1934   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000020  6ba5              LDR      r5,[r4,#0x38]
;;;1935   	}
;;;1936   	taskEXIT_CRITICAL();
000022  f7fffffe          BL       vPortExitCritical
;;;1937   
;;;1938   	return uxReturn;
000026  4628              MOV      r0,r5
;;;1939   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000028  bd70              POP      {r4-r6,pc}
;;;1940   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1958   
;;;1959   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1960   {
000002  4601              MOV      r1,r0
;;;1961   UBaseType_t uxReturn;
;;;1962   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;1963   
;;;1964   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L13.30|
000008  bf00              NOP      
00000a  2310              MOVS     r3,#0x10
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L13.28|
00001c  e7fe              B        |L13.28|
                  |L13.30|
;;;1965   	uxReturn = pxQueue->uxMessagesWaiting;
00001e  6b90              LDR      r0,[r2,#0x38]
;;;1966   
;;;1967   	return uxReturn;
;;;1968   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000020  bd10              POP      {r4,pc}
;;;1969   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1941   
;;;1942   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1943   {
000002  4604              MOV      r4,r0
;;;1944   UBaseType_t uxReturn;
;;;1945   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1946   
;;;1947   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L14.30|
000008  bf00              NOP      
00000a  2010              MOVS     r0,#0x10
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L14.28|
00001c  e7fe              B        |L14.28|
                  |L14.30|
;;;1948   
;;;1949   	taskENTER_CRITICAL();
00001e  f7fffffe          BL       vPortEnterCritical
;;;1950   	{
;;;1951   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000022  e9d5100e          LDRD     r1,r0,[r5,#0x38]
000026  1a46              SUBS     r6,r0,r1
;;;1952   	}
;;;1953   	taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;1954   
;;;1955   	return uxReturn;
00002c  4630              MOV      r0,r6
;;;1956   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00002e  bd70              POP      {r4-r6,pc}
;;;1957   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueAddToRegistry||, CODE, READONLY, ALIGN=2

                  vQueueAddToRegistry PROC
;;;2643   
;;;2644   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4602              MOV      r2,r0
;;;2645   	{
;;;2646   	UBaseType_t ux;
;;;2647   
;;;2648   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2649   		a free slot. */
;;;2650   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00b              B        |L15.30|
                  |L15.6|
;;;2651   		{
;;;2652   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000006  4b08              LDR      r3,|L15.40|
000008  f8533030          LDR      r3,[r3,r0,LSL #3]
00000c  b933              CBNZ     r3,|L15.28|
;;;2653   			{
;;;2654   				/* Store the information on this queue. */
;;;2655   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
00000e  4b06              LDR      r3,|L15.40|
000010  f8431030          STR      r1,[r3,r0,LSL #3]
;;;2656   				xQueueRegistry[ ux ].xHandle = xQueue;
000014  eb0303c0          ADD      r3,r3,r0,LSL #3
000018  605a              STR      r2,[r3,#4]
;;;2657   
;;;2658   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2659   				break;
00001a  e002              B        |L15.34|
                  |L15.28|
00001c  1c40              ADDS     r0,r0,#1              ;2650
                  |L15.30|
00001e  2808              CMP      r0,#8                 ;2650
000020  d3f1              BCC      |L15.6|
                  |L15.34|
000022  bf00              NOP      
;;;2660   			}
;;;2661   			else
;;;2662   			{
;;;2663   				mtCOVERAGE_TEST_MARKER();
;;;2664   			}
;;;2665   		}
;;;2666   	}
000024  4770              BX       lr
;;;2667   
                          ENDP

000026  0000              DCW      0x0000
                  |L15.40|
                          DCD      xQueueRegistry

                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1970   
;;;1971   void vQueueDelete( QueueHandle_t xQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;1972   {
000002  4604              MOV      r4,r0
;;;1973   Queue_t * const pxQueue = xQueue;
000004  4625              MOV      r5,r4
;;;1974   
;;;1975   	configASSERT( pxQueue );
000006  b955              CBNZ     r5,|L16.30|
000008  bf00              NOP      
00000a  2010              MOVS     r0,#0x10
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L16.28|
00001c  e7fe              B        |L16.28|
                  |L16.30|
;;;1976   	traceQUEUE_DELETE( pxQueue );
;;;1977   
;;;1978   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1979   	{
;;;1980   		vQueueUnregisterQueue( pxQueue );
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       vQueueUnregisterQueue
;;;1981   	}
;;;1982   	#endif
;;;1983   
;;;1984   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1985   	{
;;;1986   		/* The queue can only have been allocated dynamically - free it
;;;1987   		again. */
;;;1988   		vPortFree( pxQueue );
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       vPortFree
;;;1989   	}
;;;1990   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1991   	{
;;;1992   		/* The queue could have been allocated statically or dynamically, so
;;;1993   		check before attempting to free the memory. */
;;;1994   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1995   		{
;;;1996   			vPortFree( pxQueue );
;;;1997   		}
;;;1998   		else
;;;1999   		{
;;;2000   			mtCOVERAGE_TEST_MARKER();
;;;2001   		}
;;;2002   	}
;;;2003   	#else
;;;2004   	{
;;;2005   		/* The queue must have been statically allocated, so is not going to be
;;;2006   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;2007   		( void ) pxQueue;
;;;2008   	}
;;;2009   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;2010   }
00002a  bd70              POP      {r4-r6,pc}
;;;2011   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueSetQueueNumber||, CODE, READONLY, ALIGN=1

                  vQueueSetQueueNumber PROC
;;;2024   
;;;2025   	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
000000  6481              STR      r1,[r0,#0x48]
;;;2026   	{
;;;2027   		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
;;;2028   	}
000002  4770              BX       lr
;;;2029   
                          ENDP


                          AREA ||i.vQueueUnregisterQueue||, CODE, READONLY, ALIGN=2

                  vQueueUnregisterQueue PROC
;;;2700   
;;;2701   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000000  4601              MOV      r1,r0
;;;2702   	{
;;;2703   	UBaseType_t ux;
;;;2704   
;;;2705   		/* See if the handle of the queue being unregistered in actually in the
;;;2706   		registry. */
;;;2707   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000002  2000              MOVS     r0,#0
000004  e00e              B        |L18.36|
                  |L18.6|
;;;2708   		{
;;;2709   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000006  4a09              LDR      r2,|L18.44|
000008  eb0202c0          ADD      r2,r2,r0,LSL #3
00000c  6852              LDR      r2,[r2,#4]
00000e  428a              CMP      r2,r1
000010  d107              BNE      |L18.34|
;;;2710   			{
;;;2711   				/* Set the name to NULL to show that this slot if free again. */
;;;2712   				xQueueRegistry[ ux ].pcQueueName = NULL;
000012  2200              MOVS     r2,#0
000014  4b05              LDR      r3,|L18.44|
000016  f8432030          STR      r2,[r3,r0,LSL #3]
;;;2713   
;;;2714   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2715   				appear in the registry twice if it is added, removed, then
;;;2716   				added again. */
;;;2717   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
00001a  eb0303c0          ADD      r3,r3,r0,LSL #3
00001e  605a              STR      r2,[r3,#4]
;;;2718   				break;
000020  e002              B        |L18.40|
                  |L18.34|
000022  1c40              ADDS     r0,r0,#1              ;2707
                  |L18.36|
000024  2808              CMP      r0,#8                 ;2707
000026  d3ee              BCC      |L18.6|
                  |L18.40|
000028  bf00              NOP      
;;;2719   			}
;;;2720   			else
;;;2721   			{
;;;2722   				mtCOVERAGE_TEST_MARKER();
;;;2723   			}
;;;2724   		}
;;;2725   
;;;2726   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00002a  4770              BX       lr
;;;2727   
                          ENDP

                  |L18.44|
                          DCD      xQueueRegistry

                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;720    
;;;721    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b570              PUSH     {r4-r6,lr}
;;;722    	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;723    	QueueHandle_t xHandle;
;;;724    
;;;725    		configASSERT( uxMaxCount != 0 );
000006  b10d              CBZ      r5,|L19.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L19.14|
                  |L19.12|
00000c  2000              MOVS     r0,#0
                  |L19.14|
00000e  b950              CBNZ     r0,|L19.38|
000010  bf00              NOP      
000012  2010              MOVS     r0,#0x10
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L19.36|
000024  e7fe              B        |L19.36|
                  |L19.38|
;;;726    		configASSERT( uxInitialCount <= uxMaxCount );
000026  42ae              CMP      r6,r5
000028  d801              BHI      |L19.46|
00002a  2001              MOVS     r0,#1
00002c  e000              B        |L19.48|
                  |L19.46|
00002e  2000              MOVS     r0,#0
                  |L19.48|
000030  b950              CBNZ     r0,|L19.72|
000032  bf00              NOP      
000034  2010              MOVS     r0,#0x10
000036  f3808811          MSR      BASEPRI,r0
00003a  f3bf8f4f          DSB      
00003e  f3bf8f6f          ISB      
000042  bf00              NOP      
000044  bf00              NOP      
                  |L19.70|
000046  e7fe              B        |L19.70|
                  |L19.72|
;;;727    
;;;728    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000048  2202              MOVS     r2,#2
00004a  2100              MOVS     r1,#0
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       xQueueGenericCreate
000052  4604              MOV      r4,r0
;;;729    
;;;730    		if( xHandle != NULL )
000054  b104              CBZ      r4,|L19.88|
;;;731    		{
;;;732    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000056  63a6              STR      r6,[r4,#0x38]
                  |L19.88|
;;;733    
;;;734    			traceCREATE_COUNTING_SEMAPHORE();
;;;735    		}
;;;736    		else
;;;737    		{
;;;738    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;739    		}
;;;740    
;;;741    		return xHandle;
000058  4620              MOV      r0,r4
;;;742    	}
00005a  bd70              POP      {r4-r6,pc}
;;;743    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;502    
;;;503    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;504    	{
000004  4604              MOV      r4,r0
;;;505    	QueueHandle_t xNewQueue;
;;;506    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
000006  2601              MOVS     r6,#1
000008  2700              MOVS     r7,#0
;;;507    
;;;508    		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
00000a  4622              MOV      r2,r4
00000c  2100              MOVS     r1,#0
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       xQueueGenericCreate
000014  4605              MOV      r5,r0
;;;509    		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       prvInitialiseMutex
;;;510    
;;;511    		return xNewQueue;
00001c  4628              MOV      r0,r5
;;;512    	}
00001e  e8bd81f0          POP      {r4-r8,pc}
;;;513    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;367    
;;;368    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;369    	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
;;;370    	Queue_t *pxNewQueue;
;;;371    	size_t xQueueSizeInBytes;
;;;372    	uint8_t *pucQueueStorage;
;;;373    
;;;374    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
00000a  b10d              CBZ      r5,|L21.16|
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L21.18|
                  |L21.16|
000010  2000              MOVS     r0,#0
                  |L21.18|
000012  b950              CBNZ     r0,|L21.42|
000014  bf00              NOP      
000016  2010              MOVS     r0,#0x10
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L21.40|
000028  e7fe              B        |L21.40|
                  |L21.42|
;;;375    
;;;376    		if( uxItemSize == ( UBaseType_t ) 0 )
00002a  b90e              CBNZ     r6,|L21.48|
;;;377    		{
;;;378    			/* There is not going to be a queue storage area. */
;;;379    			xQueueSizeInBytes = ( size_t ) 0;
00002c  2700              MOVS     r7,#0
00002e  e001              B        |L21.52|
                  |L21.48|
;;;380    		}
;;;381    		else
;;;382    		{
;;;383    			/* Allocate enough space to hold the maximum number of items that
;;;384    			can be in the queue at any time. */
;;;385    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000030  fb05f706          MUL      r7,r5,r6
                  |L21.52|
;;;386    		}
;;;387    
;;;388    		/* Allocate the queue and storage area.  Justification for MISRA
;;;389    		deviation as follows:  pvPortMalloc() always ensures returned memory
;;;390    		blocks are aligned per the requirements of the MCU stack.  In this case
;;;391    		pvPortMalloc() must return a pointer that is guaranteed to meet the
;;;392    		alignment requirements of the Queue_t structure - which in this case
;;;393    		is an int8_t *.  Therefore, whenever the stack alignment requirements
;;;394    		are greater than or equal to the pointer to char requirements the cast
;;;395    		is safe.  In other cases alignment requirements are not strict (one or
;;;396    		two bytes). */
;;;397    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
000034  f1070050          ADD      r0,r7,#0x50
000038  f7fffffe          BL       pvPortMalloc
00003c  4604              MOV      r4,r0
;;;398    
;;;399    		if( pxNewQueue != NULL )
00003e  b14c              CBZ      r4,|L21.84|
;;;400    		{
;;;401    			/* Jump past the queue structure to find the location of the queue
;;;402    			storage area. */
;;;403    			pucQueueStorage = ( uint8_t * ) pxNewQueue;
000040  46a1              MOV      r9,r4
;;;404    			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000042  f1090950          ADD      r9,r9,#0x50
;;;405    
;;;406    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;407    			{
;;;408    				/* Queues can be created either statically or dynamically, so
;;;409    				note this task was created dynamically in case it is later
;;;410    				deleted. */
;;;411    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;412    			}
;;;413    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;414    
;;;415    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000046  4643              MOV      r3,r8
000048  464a              MOV      r2,r9
00004a  4631              MOV      r1,r6
00004c  4628              MOV      r0,r5
00004e  9400              STR      r4,[sp,#0]
000050  f7fffffe          BL       prvInitialiseNewQueue
                  |L21.84|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;420    			mtCOVERAGE_TEST_MARKER();
;;;421    		}
;;;422    
;;;423    		return pxNewQueue;
000054  4620              MOV      r0,r4
;;;424    	}
000056  e8bd83f8          POP      {r3-r9,pc}
;;;425    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=2

                  xQueueGenericReset PROC
;;;254    
;;;255    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;257    Queue_t * const pxQueue = xQueue;
000006  462c              MOV      r4,r5
;;;258    
;;;259    	configASSERT( pxQueue );
000008  b954              CBNZ     r4,|L22.32|
00000a  bf00              NOP      
00000c  2010              MOVS     r0,#0x10
00000e  f3808811          MSR      BASEPRI,r0
000012  f3bf8f4f          DSB      
000016  f3bf8f6f          ISB      
00001a  bf00              NOP      
00001c  bf00              NOP      
                  |L22.30|
00001e  e7fe              B        |L22.30|
                  |L22.32|
;;;260    
;;;261    	taskENTER_CRITICAL();
000020  f7fffffe          BL       vPortEnterCritical
;;;262    	{
;;;263    		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000024  e9d4120f          LDRD     r1,r2,[r4,#0x3c]
000028  6820              LDR      r0,[r4,#0]
00002a  fb010002          MLA      r0,r1,r2,r0
00002e  60a0              STR      r0,[r4,#8]
;;;264    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000030  2000              MOVS     r0,#0
000032  63a0              STR      r0,[r4,#0x38]
;;;265    		pxQueue->pcWriteTo = pxQueue->pcHead;
000034  6820              LDR      r0,[r4,#0]
000036  6060              STR      r0,[r4,#4]
;;;266    		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
000038  6be0              LDR      r0,[r4,#0x3c]
00003a  1e40              SUBS     r0,r0,#1
00003c  6c22              LDR      r2,[r4,#0x40]
00003e  6821              LDR      r1,[r4,#0]
000040  fb001102          MLA      r1,r0,r2,r1
000044  60e1              STR      r1,[r4,#0xc]
;;;267    		pxQueue->cRxLock = queueUNLOCKED;
000046  20ff              MOVS     r0,#0xff
000048  f8840044          STRB     r0,[r4,#0x44]
;;;268    		pxQueue->cTxLock = queueUNLOCKED;
00004c  f8840045          STRB     r0,[r4,#0x45]
;;;269    
;;;270    		if( xNewQueue == pdFALSE )
000050  b99e              CBNZ     r6,|L22.122|
;;;271    		{
;;;272    			/* If there are tasks blocked waiting to read from the queue, then
;;;273    			the tasks will remain blocked as after this function exits the queue
;;;274    			will still be empty.  If there are tasks blocked waiting to write to
;;;275    			the queue, then one should be unblocked as after this function exits
;;;276    			it will be possible to write to it. */
;;;277    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000052  6920              LDR      r0,[r4,#0x10]
000054  b908              CBNZ     r0,|L22.90|
000056  2001              MOVS     r0,#1
000058  e000              B        |L22.92|
                  |L22.90|
00005a  2000              MOVS     r0,#0
                  |L22.92|
00005c  b9a8              CBNZ     r0,|L22.138|
;;;278    			{
;;;279    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00005e  f1040010          ADD      r0,r4,#0x10
000062  f7fffffe          BL       xTaskRemoveFromEventList
000066  b180              CBZ      r0,|L22.138|
;;;280    				{
;;;281    					queueYIELD_IF_USING_PREEMPTION();
000068  f04f5080          MOV      r0,#0x10000000
00006c  4909              LDR      r1,|L22.148|
00006e  6008              STR      r0,[r1,#0]
000070  f3bf8f4f          DSB      
000074  f3bf8f6f          ISB      
000078  e007              B        |L22.138|
                  |L22.122|
;;;282    				}
;;;283    				else
;;;284    				{
;;;285    					mtCOVERAGE_TEST_MARKER();
;;;286    				}
;;;287    			}
;;;288    			else
;;;289    			{
;;;290    				mtCOVERAGE_TEST_MARKER();
;;;291    			}
;;;292    		}
;;;293    		else
;;;294    		{
;;;295    			/* Ensure the event queues start in the correct state. */
;;;296    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
00007a  f1040010          ADD      r0,r4,#0x10
00007e  f7fffffe          BL       vListInitialise
;;;297    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000082  f1040024          ADD      r0,r4,#0x24
000086  f7fffffe          BL       vListInitialise
                  |L22.138|
;;;298    		}
;;;299    	}
;;;300    	taskEXIT_CRITICAL();
00008a  f7fffffe          BL       vPortExitCritical
;;;301    
;;;302    	/* A value is returned for calling semantic consistency with previous
;;;303    	versions. */
;;;304    	return pdPASS;
00008e  2001              MOVS     r0,#1
;;;305    }
000090  bd70              POP      {r4-r6,pc}
;;;306    /*-----------------------------------------------------------*/
                          ENDP

000092  0000              DCW      0x0000
                  |L22.148|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=2

                  xQueueGenericSend PROC
;;;746    
;;;747    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  e92d43ff          PUSH     {r0-r9,lr}
;;;748    {
000004  b083              SUB      sp,sp,#0xc
000006  4606              MOV      r6,r0
000008  4688              MOV      r8,r1
00000a  461d              MOV      r5,r3
;;;749    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
00000c  f04f0900          MOV      r9,#0
;;;750    TimeOut_t xTimeOut;
;;;751    Queue_t * const pxQueue = xQueue;
000010  4634              MOV      r4,r6
;;;752    
;;;753    	configASSERT( pxQueue );
000012  b954              CBNZ     r4,|L23.42|
000014  bf00              NOP      
000016  2010              MOVS     r0,#0x10
000018  f3808811          MSR      BASEPRI,r0
00001c  f3bf8f4f          DSB      
000020  f3bf8f6f          ISB      
000024  bf00              NOP      
000026  bf00              NOP      
                  |L23.40|
000028  e7fe              B        |L23.40|
                  |L23.42|
;;;754    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
00002a  f1b80f00          CMP      r8,#0
00002e  d101              BNE      |L23.52|
000030  6c20              LDR      r0,[r4,#0x40]
000032  b908              CBNZ     r0,|L23.56|
                  |L23.52|
000034  2001              MOVS     r0,#1
000036  e000              B        |L23.58|
                  |L23.56|
000038  2000              MOVS     r0,#0
                  |L23.58|
00003a  b950              CBNZ     r0,|L23.82|
00003c  bf00              NOP      
00003e  2010              MOVS     r0,#0x10
000040  f3808811          MSR      BASEPRI,r0
000044  f3bf8f4f          DSB      
000048  f3bf8f6f          ISB      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L23.80|
000050  e7fe              B        |L23.80|
                  |L23.82|
;;;755    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
000052  2d02              CMP      r5,#2
000054  d102              BNE      |L23.92|
000056  6be0              LDR      r0,[r4,#0x3c]
000058  2801              CMP      r0,#1
00005a  d101              BNE      |L23.96|
                  |L23.92|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L23.98|
                  |L23.96|
000060  2000              MOVS     r0,#0
                  |L23.98|
000062  b950              CBNZ     r0,|L23.122|
000064  bf00              NOP      
000066  2010              MOVS     r0,#0x10
000068  f3808811          MSR      BASEPRI,r0
00006c  f3bf8f4f          DSB      
000070  f3bf8f6f          ISB      
000074  bf00              NOP      
000076  bf00              NOP      
                  |L23.120|
000078  e7fe              B        |L23.120|
                  |L23.122|
;;;756    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;757    	{
;;;758    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;759    	}
;;;760    	#endif
;;;761    
;;;762    
;;;763    	/*lint -save -e904 This function relaxes the coding standard somewhat to
;;;764    	allow return statements within the function itself.  This is done in the
;;;765    	interest of execution time efficiency. */
;;;766    	for( ;; )
00007a  bf00              NOP      
                  |L23.124|
;;;767    	{
;;;768    		taskENTER_CRITICAL();
00007c  f7fffffe          BL       vPortEnterCritical
;;;769    		{
;;;770    			/* Is there room on the queue now?  The running task must be the
;;;771    			highest priority task wanting to access the queue.  If the head item
;;;772    			in the queue is to be overwritten then it does not matter if the
;;;773    			queue is full. */
;;;774    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000080  6ba0              LDR      r0,[r4,#0x38]
000082  6be1              LDR      r1,[r4,#0x3c]
000084  4288              CMP      r0,r1
000086  d301              BCC      |L23.140|
000088  2d02              CMP      r5,#2
00008a  d128              BNE      |L23.222|
                  |L23.140|
;;;775    			{
;;;776    				traceQUEUE_SEND( pxQueue );
;;;777    
;;;778    				#if ( configUSE_QUEUE_SETS == 1 )
;;;779    				{
;;;780    				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;781    
;;;782    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;783    
;;;784    					if( pxQueue->pxQueueSetContainer != NULL )
;;;785    					{
;;;786    						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
;;;787    						{
;;;788    							/* Do not notify the queue set as an existing item
;;;789    							was overwritten in the queue so the number of items
;;;790    							in the queue has not changed. */
;;;791    							mtCOVERAGE_TEST_MARKER();
;;;792    						}
;;;793    						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;794    						{
;;;795    							/* The queue is a member of a queue set, and posting
;;;796    							to the queue set caused a higher priority task to
;;;797    							unblock. A context switch is required. */
;;;798    							queueYIELD_IF_USING_PREEMPTION();
;;;799    						}
;;;800    						else
;;;801    						{
;;;802    							mtCOVERAGE_TEST_MARKER();
;;;803    						}
;;;804    					}
;;;805    					else
;;;806    					{
;;;807    						/* If there was a task waiting for data to arrive on the
;;;808    						queue then unblock it now. */
;;;809    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;810    						{
;;;811    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;812    							{
;;;813    								/* The unblocked task has a priority higher than
;;;814    								our own so yield immediately.  Yes it is ok to
;;;815    								do this from within the critical section - the
;;;816    								kernel takes care of that. */
;;;817    								queueYIELD_IF_USING_PREEMPTION();
;;;818    							}
;;;819    							else
;;;820    							{
;;;821    								mtCOVERAGE_TEST_MARKER();
;;;822    							}
;;;823    						}
;;;824    						else if( xYieldRequired != pdFALSE )
;;;825    						{
;;;826    							/* This path is a special case that will only get
;;;827    							executed if the task was holding multiple mutexes
;;;828    							and the mutexes were given back in an order that is
;;;829    							different to that in which they were taken. */
;;;830    							queueYIELD_IF_USING_PREEMPTION();
;;;831    						}
;;;832    						else
;;;833    						{
;;;834    							mtCOVERAGE_TEST_MARKER();
;;;835    						}
;;;836    					}
;;;837    				}
;;;838    				#else /* configUSE_QUEUE_SETS */
;;;839    				{
;;;840    					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
00008c  462a              MOV      r2,r5
00008e  4641              MOV      r1,r8
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       prvCopyDataToQueue
000096  4607              MOV      r7,r0
;;;841    
;;;842    					/* If there was a task waiting for data to arrive on the
;;;843    					queue then unblock it now. */
;;;844    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000098  6a60              LDR      r0,[r4,#0x24]
00009a  b908              CBNZ     r0,|L23.160|
00009c  2001              MOVS     r0,#1
00009e  e000              B        |L23.162|
                  |L23.160|
0000a0  2000              MOVS     r0,#0
                  |L23.162|
0000a2  b968              CBNZ     r0,|L23.192|
;;;845    					{
;;;846    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000a4  f1040024          ADD      r0,r4,#0x24
0000a8  f7fffffe          BL       xTaskRemoveFromEventList
0000ac  b188              CBZ      r0,|L23.210|
;;;847    						{
;;;848    							/* The unblocked task has a priority higher than
;;;849    							our own so yield immediately.  Yes it is ok to do
;;;850    							this from within the critical section - the kernel
;;;851    							takes care of that. */
;;;852    							queueYIELD_IF_USING_PREEMPTION();
0000ae  f04f5080          MOV      r0,#0x10000000
0000b2  4932              LDR      r1,|L23.380|
0000b4  6008              STR      r0,[r1,#0]
0000b6  f3bf8f4f          DSB      
0000ba  f3bf8f6f          ISB      
0000be  e008              B        |L23.210|
                  |L23.192|
;;;853    						}
;;;854    						else
;;;855    						{
;;;856    							mtCOVERAGE_TEST_MARKER();
;;;857    						}
;;;858    					}
;;;859    					else if( xYieldRequired != pdFALSE )
0000c0  b13f              CBZ      r7,|L23.210|
;;;860    					{
;;;861    						/* This path is a special case that will only get
;;;862    						executed if the task was holding multiple mutexes and
;;;863    						the mutexes were given back in an order that is
;;;864    						different to that in which they were taken. */
;;;865    						queueYIELD_IF_USING_PREEMPTION();
0000c2  f04f5080          MOV      r0,#0x10000000
0000c6  492d              LDR      r1,|L23.380|
0000c8  6008              STR      r0,[r1,#0]
0000ca  f3bf8f4f          DSB      
0000ce  f3bf8f6f          ISB      
                  |L23.210|
;;;866    					}
;;;867    					else
;;;868    					{
;;;869    						mtCOVERAGE_TEST_MARKER();
;;;870    					}
;;;871    				}
;;;872    				#endif /* configUSE_QUEUE_SETS */
;;;873    
;;;874    				taskEXIT_CRITICAL();
0000d2  f7fffffe          BL       vPortExitCritical
;;;875    				return pdPASS;
0000d6  2001              MOVS     r0,#1
                  |L23.216|
;;;876    			}
;;;877    			else
;;;878    			{
;;;879    				if( xTicksToWait == ( TickType_t ) 0 )
;;;880    				{
;;;881    					/* The queue was full and no block time is specified (or
;;;882    					the block time has expired) so leave now. */
;;;883    					taskEXIT_CRITICAL();
;;;884    
;;;885    					/* Return to the original privilege level before exiting
;;;886    					the function. */
;;;887    					traceQUEUE_SEND_FAILED( pxQueue );
;;;888    					return errQUEUE_FULL;
;;;889    				}
;;;890    				else if( xEntryTimeSet == pdFALSE )
;;;891    				{
;;;892    					/* The queue was full and a block time was specified so
;;;893    					configure the timeout structure. */
;;;894    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;895    					xEntryTimeSet = pdTRUE;
;;;896    				}
;;;897    				else
;;;898    				{
;;;899    					/* Entry time was already set. */
;;;900    					mtCOVERAGE_TEST_MARKER();
;;;901    				}
;;;902    			}
;;;903    		}
;;;904    		taskEXIT_CRITICAL();
;;;905    
;;;906    		/* Interrupts and other tasks can send to and receive from the queue
;;;907    		now the critical section has been exited. */
;;;908    
;;;909    		vTaskSuspendAll();
;;;910    		prvLockQueue( pxQueue );
;;;911    
;;;912    		/* Update the timeout state to see if it has expired yet. */
;;;913    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;914    		{
;;;915    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;916    			{
;;;917    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;918    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;919    
;;;920    				/* Unlocking the queue means queue events can effect the
;;;921    				event list.  It is possible that interrupts occurring now
;;;922    				remove this task from the event list again - but as the
;;;923    				scheduler is suspended the task will go onto the pending
;;;924    				ready last instead of the actual ready list. */
;;;925    				prvUnlockQueue( pxQueue );
;;;926    
;;;927    				/* Resuming the scheduler will move tasks from the pending
;;;928    				ready list into the ready list - so it is feasible that this
;;;929    				task is already in a ready list before it yields - in which
;;;930    				case the yield will not cause a context switch unless there
;;;931    				is also a higher priority task in the pending ready list. */
;;;932    				if( xTaskResumeAll() == pdFALSE )
;;;933    				{
;;;934    					portYIELD_WITHIN_API();
;;;935    				}
;;;936    			}
;;;937    			else
;;;938    			{
;;;939    				/* Try again. */
;;;940    				prvUnlockQueue( pxQueue );
;;;941    				( void ) xTaskResumeAll();
;;;942    			}
;;;943    		}
;;;944    		else
;;;945    		{
;;;946    			/* The timeout has expired. */
;;;947    			prvUnlockQueue( pxQueue );
;;;948    			( void ) xTaskResumeAll();
;;;949    
;;;950    			traceQUEUE_SEND_FAILED( pxQueue );
;;;951    			return errQUEUE_FULL;
;;;952    		}
;;;953    	} /*lint -restore */
;;;954    }
0000d8  b007              ADD      sp,sp,#0x1c
0000da  e8bd83f0          POP      {r4-r9,pc}
                  |L23.222|
0000de  9805              LDR      r0,[sp,#0x14]         ;879
0000e0  b918              CBNZ     r0,|L23.234|
0000e2  f7fffffe          BL       vPortExitCritical
0000e6  2000              MOVS     r0,#0                 ;888
0000e8  e7f6              B        |L23.216|
                  |L23.234|
0000ea  f1b90f00          CMP      r9,#0                 ;890
0000ee  d104              BNE      |L23.250|
0000f0  a801              ADD      r0,sp,#4              ;894
0000f2  f7fffffe          BL       vTaskInternalSetTimeOutState
0000f6  f04f0901          MOV      r9,#1                 ;895
                  |L23.250|
0000fa  f7fffffe          BL       vPortExitCritical
0000fe  f7fffffe          BL       vTaskSuspendAll
000102  f7fffffe          BL       vPortEnterCritical
000106  f9940044          LDRSB    r0,[r4,#0x44]         ;910
00010a  1c40              ADDS     r0,r0,#1              ;910
00010c  b910              CBNZ     r0,|L23.276|
00010e  2000              MOVS     r0,#0                 ;910
000110  f8840044          STRB     r0,[r4,#0x44]         ;910
                  |L23.276|
000114  f9940045          LDRSB    r0,[r4,#0x45]         ;910
000118  1c40              ADDS     r0,r0,#1              ;910
00011a  b910              CBNZ     r0,|L23.290|
00011c  2000              MOVS     r0,#0                 ;910
00011e  f8840045          STRB     r0,[r4,#0x45]         ;910
                  |L23.290|
000122  f7fffffe          BL       vPortExitCritical
000126  a905              ADD      r1,sp,#0x14           ;913
000128  a801              ADD      r0,sp,#4              ;913
00012a  f7fffffe          BL       xTaskCheckForTimeOut
00012e  b9f0              CBNZ     r0,|L23.366|
000130  4620              MOV      r0,r4                 ;915
000132  f7fffffe          BL       prvIsQueueFull
000136  b1a0              CBZ      r0,|L23.354|
000138  f1040010          ADD      r0,r4,#0x10           ;918
00013c  9905              LDR      r1,[sp,#0x14]         ;918
00013e  f7fffffe          BL       vTaskPlaceOnEventList
000142  4620              MOV      r0,r4                 ;925
000144  f7fffffe          BL       prvUnlockQueue
000148  f7fffffe          BL       xTaskResumeAll
00014c  2800              CMP      r0,#0                 ;932
00014e  d195              BNE      |L23.124|
000150  f04f5080          MOV      r0,#0x10000000        ;934
000154  4909              LDR      r1,|L23.380|
000156  6008              STR      r0,[r1,#0]            ;934
000158  f3bf8f4f          DSB                            ;934
00015c  f3bf8f6f          ISB                            ;934
000160  e78c              B        |L23.124|
                  |L23.354|
000162  4620              MOV      r0,r4                 ;940
000164  f7fffffe          BL       prvUnlockQueue
000168  f7fffffe          BL       xTaskResumeAll
00016c  e786              B        |L23.124|
                  |L23.366|
00016e  4620              MOV      r0,r4                 ;947
000170  f7fffffe          BL       prvUnlockQueue
000174  f7fffffe          BL       xTaskResumeAll
000178  2000              MOVS     r0,#0                 ;951
00017a  e7ad              B        |L23.216|
;;;955    /*-----------------------------------------------------------*/
                          ENDP

                  |L23.380|
                          DCD      0xe000ed04

                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;956    
;;;957    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;958    {
000004  4607              MOV      r7,r0
000006  468a              MOV      r10,r1
000008  4690              MOV      r8,r2
00000a  461e              MOV      r6,r3
;;;959    BaseType_t xReturn;
;;;960    UBaseType_t uxSavedInterruptStatus;
;;;961    Queue_t * const pxQueue = xQueue;
00000c  463c              MOV      r4,r7
;;;962    
;;;963    	configASSERT( pxQueue );
00000e  b954              CBNZ     r4,|L24.38|
000010  bf00              NOP      
000012  2010              MOVS     r0,#0x10
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L24.36|
000024  e7fe              B        |L24.36|
                  |L24.38|
;;;964    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000026  f1ba0f00          CMP      r10,#0
00002a  d101              BNE      |L24.48|
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b908              CBNZ     r0,|L24.52|
                  |L24.48|
000030  2001              MOVS     r0,#1
000032  e000              B        |L24.54|
                  |L24.52|
000034  2000              MOVS     r0,#0
                  |L24.54|
000036  b950              CBNZ     r0,|L24.78|
000038  bf00              NOP      
00003a  2010              MOVS     r0,#0x10
00003c  f3808811          MSR      BASEPRI,r0
000040  f3bf8f4f          DSB      
000044  f3bf8f6f          ISB      
000048  bf00              NOP      
00004a  bf00              NOP      
                  |L24.76|
00004c  e7fe              B        |L24.76|
                  |L24.78|
;;;965    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00004e  2e02              CMP      r6,#2
000050  d102              BNE      |L24.88|
000052  6be0              LDR      r0,[r4,#0x3c]
000054  2801              CMP      r0,#1
000056  d101              BNE      |L24.92|
                  |L24.88|
000058  2001              MOVS     r0,#1
00005a  e000              B        |L24.94|
                  |L24.92|
00005c  2000              MOVS     r0,#0
                  |L24.94|
00005e  b950              CBNZ     r0,|L24.118|
000060  bf00              NOP      
000062  2010              MOVS     r0,#0x10
000064  f3808811          MSR      BASEPRI,r0
000068  f3bf8f4f          DSB      
00006c  f3bf8f6f          ISB      
000070  bf00              NOP      
000072  bf00              NOP      
                  |L24.116|
000074  e7fe              B        |L24.116|
                  |L24.118|
;;;966    
;;;967    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;968    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;969    	above the maximum system call priority are kept permanently enabled, even
;;;970    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;971    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;972    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;973    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;974    	assigned a priority above the configured maximum system call priority.
;;;975    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;976    	that have been assigned a priority at or (logically) below the maximum
;;;977    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;978    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;979    	More information (albeit Cortex-M specific) is provided on the following
;;;980    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;981    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000076  f7fffffe          BL       vPortValidateInterruptPriority
;;;982    
;;;983    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;984    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;985    	read, instead return a flag to say whether a context switch is required or
;;;986    	not (i.e. has a task with a higher priority than us been woken by this
;;;987    	post). */
;;;988    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00007a  bf00              NOP      
00007c  2110              MOVS     r1,#0x10
00007e  f3ef8011          MRS      r0,BASEPRI
000082  f3818811          MSR      BASEPRI,r1
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
00008e  bf00              NOP      
000090  4605              MOV      r5,r0
;;;989    	{
;;;990    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000092  6ba0              LDR      r0,[r4,#0x38]
000094  6be1              LDR      r1,[r4,#0x3c]
000096  4288              CMP      r0,r1
000098  d301              BCC      |L24.158|
00009a  2e02              CMP      r6,#2
00009c  d123              BNE      |L24.230|
                  |L24.158|
;;;991    		{
;;;992    			const int8_t cTxLock = pxQueue->cTxLock;
00009e  f994b045          LDRSB    r11,[r4,#0x45]
;;;993    
;;;994    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;995    
;;;996    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;997    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;998    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;999    			called here even though the disinherit function does not check if
;;;1000   			the scheduler is suspended before accessing the ready lists. */
;;;1001   			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0000a2  4632              MOV      r2,r6
0000a4  4651              MOV      r1,r10
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       prvCopyDataToQueue
;;;1002   
;;;1003   			/* The event list is not altered if the queue is locked.  This will
;;;1004   			be done when the queue is unlocked later. */
;;;1005   			if( cTxLock == queueUNLOCKED )
0000ac  f10b0001          ADD      r0,r11,#1
0000b0  b988              CBNZ     r0,|L24.214|
;;;1006   			{
;;;1007   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1008   				{
;;;1009   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1010   					{
;;;1011   						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;1012   						{
;;;1013   							/* The queue is a member of a queue set, and posting
;;;1014   							to the queue set caused a higher priority task to
;;;1015   							unblock.  A context switch is required. */
;;;1016   							if( pxHigherPriorityTaskWoken != NULL )
;;;1017   							{
;;;1018   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1019   							}
;;;1020   							else
;;;1021   							{
;;;1022   								mtCOVERAGE_TEST_MARKER();
;;;1023   							}
;;;1024   						}
;;;1025   						else
;;;1026   						{
;;;1027   							mtCOVERAGE_TEST_MARKER();
;;;1028   						}
;;;1029   					}
;;;1030   					else
;;;1031   					{
;;;1032   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1033   						{
;;;1034   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1035   							{
;;;1036   								/* The task waiting has a higher priority so
;;;1037   								record that a context switch is required. */
;;;1038   								if( pxHigherPriorityTaskWoken != NULL )
;;;1039   								{
;;;1040   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1041   								}
;;;1042   								else
;;;1043   								{
;;;1044   									mtCOVERAGE_TEST_MARKER();
;;;1045   								}
;;;1046   							}
;;;1047   							else
;;;1048   							{
;;;1049   								mtCOVERAGE_TEST_MARKER();
;;;1050   							}
;;;1051   						}
;;;1052   						else
;;;1053   						{
;;;1054   							mtCOVERAGE_TEST_MARKER();
;;;1055   						}
;;;1056   					}
;;;1057   				}
;;;1058   				#else /* configUSE_QUEUE_SETS */
;;;1059   				{
;;;1060   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000b2  6a60              LDR      r0,[r4,#0x24]
0000b4  b908              CBNZ     r0,|L24.186|
0000b6  2001              MOVS     r0,#1
0000b8  e000              B        |L24.188|
                  |L24.186|
0000ba  2000              MOVS     r0,#0
                  |L24.188|
0000bc  b980              CBNZ     r0,|L24.224|
;;;1061   					{
;;;1062   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000be  f1040024          ADD      r0,r4,#0x24
0000c2  f7fffffe          BL       xTaskRemoveFromEventList
0000c6  b158              CBZ      r0,|L24.224|
;;;1063   						{
;;;1064   							/* The task waiting has a higher priority so record that a
;;;1065   							context	switch is required. */
;;;1066   							if( pxHigherPriorityTaskWoken != NULL )
0000c8  f1b80f00          CMP      r8,#0
0000cc  d008              BEQ      |L24.224|
;;;1067   							{
;;;1068   								*pxHigherPriorityTaskWoken = pdTRUE;
0000ce  2001              MOVS     r0,#1
0000d0  f8c80000          STR      r0,[r8,#0]
0000d4  e004              B        |L24.224|
                  |L24.214|
;;;1069   							}
;;;1070   							else
;;;1071   							{
;;;1072   								mtCOVERAGE_TEST_MARKER();
;;;1073   							}
;;;1074   						}
;;;1075   						else
;;;1076   						{
;;;1077   							mtCOVERAGE_TEST_MARKER();
;;;1078   						}
;;;1079   					}
;;;1080   					else
;;;1081   					{
;;;1082   						mtCOVERAGE_TEST_MARKER();
;;;1083   					}
;;;1084   				}
;;;1085   				#endif /* configUSE_QUEUE_SETS */
;;;1086   			}
;;;1087   			else
;;;1088   			{
;;;1089   				/* Increment the lock count so the task that unlocks the queue
;;;1090   				knows that data was posted while it was locked. */
;;;1091   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000d6  f10b0001          ADD      r0,r11,#1
0000da  b240              SXTB     r0,r0
0000dc  f8840045          STRB     r0,[r4,#0x45]
                  |L24.224|
;;;1092   			}
;;;1093   
;;;1094   			xReturn = pdPASS;
0000e0  f04f0901          MOV      r9,#1
;;;1095   		}
0000e4  e001              B        |L24.234|
                  |L24.230|
;;;1096   		else
;;;1097   		{
;;;1098   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1099   			xReturn = errQUEUE_FULL;
0000e6  f04f0900          MOV      r9,#0
                  |L24.234|
;;;1100   		}
;;;1101   	}
;;;1102   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000ea  bf00              NOP      
0000ec  f3858811          MSR      BASEPRI,r5
0000f0  bf00              NOP      
;;;1103   
;;;1104   	return xReturn;
0000f2  4648              MOV      r0,r9
;;;1105   }
0000f4  e8bd9ff0          POP      {r4-r12,pc}
;;;1106   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1107   
;;;1108   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1109   {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;1110   BaseType_t xReturn;
;;;1111   UBaseType_t uxSavedInterruptStatus;
;;;1112   Queue_t * const pxQueue = xQueue;
000008  4634              MOV      r4,r6
;;;1113   
;;;1114   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1115   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1116   	read, instead return a flag to say whether a context switch is required or
;;;1117   	not (i.e. has a task with a higher priority than us been woken by this
;;;1118   	post). */
;;;1119   
;;;1120   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L25.34|
00000c  bf00              NOP      
00000e  2010              MOVS     r0,#0x10
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L25.32|
000020  e7fe              B        |L25.32|
                  |L25.34|
;;;1121   
;;;1122   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1123   	if the item size is not 0. */
;;;1124   	configASSERT( pxQueue->uxItemSize == 0 );
000022  6c20              LDR      r0,[r4,#0x40]
000024  b908              CBNZ     r0,|L25.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L25.44|
                  |L25.42|
00002a  2000              MOVS     r0,#0
                  |L25.44|
00002c  b950              CBNZ     r0,|L25.68|
00002e  bf00              NOP      
000030  2010              MOVS     r0,#0x10
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L25.66|
000042  e7fe              B        |L25.66|
                  |L25.68|
;;;1125   
;;;1126   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1127   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1128   	interrupts, only tasks. */
;;;1129   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
000044  6820              LDR      r0,[r4,#0]
000046  b908              CBNZ     r0,|L25.76|
000048  68a0              LDR      r0,[r4,#8]
00004a  b908              CBNZ     r0,|L25.80|
                  |L25.76|
00004c  2001              MOVS     r0,#1
00004e  e000              B        |L25.82|
                  |L25.80|
000050  2000              MOVS     r0,#0
                  |L25.82|
000052  b950              CBNZ     r0,|L25.106|
000054  bf00              NOP      
000056  2010              MOVS     r0,#0x10
000058  f3808811          MSR      BASEPRI,r0
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  bf00              NOP      
                  |L25.104|
000068  e7fe              B        |L25.104|
                  |L25.106|
;;;1130   
;;;1131   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1132   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1133   	above the maximum system call priority are kept permanently enabled, even
;;;1134   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1135   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1136   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1137   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1138   	assigned a priority above the configured maximum system call priority.
;;;1139   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1140   	that have been assigned a priority at or (logically) below the maximum
;;;1141   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1142   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1143   	More information (albeit Cortex-M specific) is provided on the following
;;;1144   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1145   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006a  f7fffffe          BL       vPortValidateInterruptPriority
;;;1146   
;;;1147   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00006e  bf00              NOP      
000070  2110              MOVS     r1,#0x10
000072  f3ef8011          MRS      r0,BASEPRI
000076  f3818811          MSR      BASEPRI,r1
00007a  f3bf8f4f          DSB      
00007e  f3bf8f6f          ISB      
000082  bf00              NOP      
000084  4605              MOV      r5,r0
;;;1148   	{
;;;1149   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000086  f8d49038          LDR      r9,[r4,#0x38]
;;;1150   
;;;1151   		/* When the queue is used to implement a semaphore no data is ever
;;;1152   		moved through the queue but it is still valid to see if the queue 'has
;;;1153   		space'. */
;;;1154   		if( uxMessagesWaiting < pxQueue->uxLength )
00008a  6be0              LDR      r0,[r4,#0x3c]
00008c  4548              CMP      r0,r9
00008e  d91e              BLS      |L25.206|
;;;1155   		{
;;;1156   			const int8_t cTxLock = pxQueue->cTxLock;
000090  f994a045          LDRSB    r10,[r4,#0x45]
;;;1157   
;;;1158   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1159   
;;;1160   			/* A task can only have an inherited priority if it is a mutex
;;;1161   			holder - and if there is a mutex holder then the mutex cannot be
;;;1162   			given from an ISR.  As this is the ISR version of the function it
;;;1163   			can be assumed there is no mutex holder and no need to determine if
;;;1164   			priority disinheritance is needed.  Simply increase the count of
;;;1165   			messages (semaphores) available. */
;;;1166   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000094  f1090001          ADD      r0,r9,#1
000098  63a0              STR      r0,[r4,#0x38]
;;;1167   
;;;1168   			/* The event list is not altered if the queue is locked.  This will
;;;1169   			be done when the queue is unlocked later. */
;;;1170   			if( cTxLock == queueUNLOCKED )
00009a  f10a0001          ADD      r0,r10,#1
00009e  b970              CBNZ     r0,|L25.190|
;;;1171   			{
;;;1172   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1173   				{
;;;1174   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1175   					{
;;;1176   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1177   						{
;;;1178   							/* The semaphore is a member of a queue set, and
;;;1179   							posting	to the queue set caused a higher priority
;;;1180   							task to	unblock.  A context switch is required. */
;;;1181   							if( pxHigherPriorityTaskWoken != NULL )
;;;1182   							{
;;;1183   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1184   							}
;;;1185   							else
;;;1186   							{
;;;1187   								mtCOVERAGE_TEST_MARKER();
;;;1188   							}
;;;1189   						}
;;;1190   						else
;;;1191   						{
;;;1192   							mtCOVERAGE_TEST_MARKER();
;;;1193   						}
;;;1194   					}
;;;1195   					else
;;;1196   					{
;;;1197   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1198   						{
;;;1199   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1200   							{
;;;1201   								/* The task waiting has a higher priority so
;;;1202   								record that a context switch is required. */
;;;1203   								if( pxHigherPriorityTaskWoken != NULL )
;;;1204   								{
;;;1205   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1206   								}
;;;1207   								else
;;;1208   								{
;;;1209   									mtCOVERAGE_TEST_MARKER();
;;;1210   								}
;;;1211   							}
;;;1212   							else
;;;1213   							{
;;;1214   								mtCOVERAGE_TEST_MARKER();
;;;1215   							}
;;;1216   						}
;;;1217   						else
;;;1218   						{
;;;1219   							mtCOVERAGE_TEST_MARKER();
;;;1220   						}
;;;1221   					}
;;;1222   				}
;;;1223   				#else /* configUSE_QUEUE_SETS */
;;;1224   				{
;;;1225   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0000a0  6a60              LDR      r0,[r4,#0x24]
0000a2  b908              CBNZ     r0,|L25.168|
0000a4  2001              MOVS     r0,#1
0000a6  e000              B        |L25.170|
                  |L25.168|
0000a8  2000              MOVS     r0,#0
                  |L25.170|
0000aa  b968              CBNZ     r0,|L25.200|
;;;1226   					{
;;;1227   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000ac  f1040024          ADD      r0,r4,#0x24
0000b0  f7fffffe          BL       xTaskRemoveFromEventList
0000b4  b140              CBZ      r0,|L25.200|
;;;1228   						{
;;;1229   							/* The task waiting has a higher priority so record that a
;;;1230   							context	switch is required. */
;;;1231   							if( pxHigherPriorityTaskWoken != NULL )
0000b6  b13f              CBZ      r7,|L25.200|
;;;1232   							{
;;;1233   								*pxHigherPriorityTaskWoken = pdTRUE;
0000b8  2001              MOVS     r0,#1
0000ba  6038              STR      r0,[r7,#0]
0000bc  e004              B        |L25.200|
                  |L25.190|
;;;1234   							}
;;;1235   							else
;;;1236   							{
;;;1237   								mtCOVERAGE_TEST_MARKER();
;;;1238   							}
;;;1239   						}
;;;1240   						else
;;;1241   						{
;;;1242   							mtCOVERAGE_TEST_MARKER();
;;;1243   						}
;;;1244   					}
;;;1245   					else
;;;1246   					{
;;;1247   						mtCOVERAGE_TEST_MARKER();
;;;1248   					}
;;;1249   				}
;;;1250   				#endif /* configUSE_QUEUE_SETS */
;;;1251   			}
;;;1252   			else
;;;1253   			{
;;;1254   				/* Increment the lock count so the task that unlocks the queue
;;;1255   				knows that data was posted while it was locked. */
;;;1256   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
0000be  f10a0001          ADD      r0,r10,#1
0000c2  b240              SXTB     r0,r0
0000c4  f8840045          STRB     r0,[r4,#0x45]
                  |L25.200|
;;;1257   			}
;;;1258   
;;;1259   			xReturn = pdPASS;
0000c8  f04f0801          MOV      r8,#1
;;;1260   		}
0000cc  e001              B        |L25.210|
                  |L25.206|
;;;1261   		else
;;;1262   		{
;;;1263   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1264   			xReturn = errQUEUE_FULL;
0000ce  f04f0800          MOV      r8,#0
                  |L25.210|
;;;1265   		}
;;;1266   	}
;;;1267   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000d2  bf00              NOP      
0000d4  f3858811          MSR      BASEPRI,r5
0000d8  bf00              NOP      
;;;1268   
;;;1269   	return xReturn;
0000da  4640              MOV      r0,r8
;;;1270   }
0000dc  e8bd87f0          POP      {r4-r10,pc}
;;;1271   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGiveMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueGiveMutexRecursive PROC
;;;595    
;;;596    	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
000000  b570              PUSH     {r4-r6,lr}
;;;597    	{
000002  4605              MOV      r5,r0
;;;598    	BaseType_t xReturn;
;;;599    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000004  462c              MOV      r4,r5
;;;600    
;;;601    		configASSERT( pxMutex );
000006  b954              CBNZ     r4,|L26.30|
000008  bf00              NOP      
00000a  2010              MOVS     r0,#0x10
00000c  f3808811          MSR      BASEPRI,r0
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L26.28|
00001c  e7fe              B        |L26.28|
                  |L26.30|
;;;602    
;;;603    		/* If this is the task that holds the mutex then xMutexHolder will not
;;;604    		change outside of this task.  If this task does not hold the mutex then
;;;605    		pxMutexHolder can never coincidentally equal the tasks handle, and as
;;;606    		this is the only condition we are interested in it does not matter if
;;;607    		pxMutexHolder is accessed simultaneously by another task.  Therefore no
;;;608    		mutual exclusion is required to test the pxMutexHolder variable. */
;;;609    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
00001e  f7fffffe          BL       xTaskGetCurrentTaskHandle
000022  68a1              LDR      r1,[r4,#8]
000024  4288              CMP      r0,r1
000026  d10c              BNE      |L26.66|
;;;610    		{
;;;611    			traceGIVE_MUTEX_RECURSIVE( pxMutex );
;;;612    
;;;613    			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
;;;614    			the task handle, therefore no underflow check is required.  Also,
;;;615    			uxRecursiveCallCount is only modified by the mutex holder, and as
;;;616    			there can only be one, no mutual exclusion is required to modify the
;;;617    			uxRecursiveCallCount member. */
;;;618    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1e40              SUBS     r0,r0,#1
00002c  60e0              STR      r0,[r4,#0xc]
;;;619    
;;;620    			/* Has the recursive call count unwound to 0? */
;;;621    			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
00002e  68e0              LDR      r0,[r4,#0xc]
000030  b928              CBNZ     r0,|L26.62|
;;;622    			{
;;;623    				/* Return the mutex.  This will automatically unblock any other
;;;624    				task that might be waiting to access the mutex. */
;;;625    				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
000032  2300              MOVS     r3,#0
000034  461a              MOV      r2,r3
000036  4619              MOV      r1,r3
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xQueueGenericSend
                  |L26.62|
;;;626    			}
;;;627    			else
;;;628    			{
;;;629    				mtCOVERAGE_TEST_MARKER();
;;;630    			}
;;;631    
;;;632    			xReturn = pdPASS;
00003e  2601              MOVS     r6,#1
000040  e000              B        |L26.68|
                  |L26.66|
;;;633    		}
;;;634    		else
;;;635    		{
;;;636    			/* The mutex cannot be given because the calling task is not the
;;;637    			holder. */
;;;638    			xReturn = pdFAIL;
000042  2600              MOVS     r6,#0
                  |L26.68|
;;;639    
;;;640    			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;641    		}
;;;642    
;;;643    		return xReturn;
000044  4630              MOV      r0,r6
;;;644    	}
000046  bd70              POP      {r4-r6,pc}
;;;645    
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2307   
;;;2308   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2309   {
000002  4601              MOV      r1,r0
;;;2310   BaseType_t xReturn;
;;;2311   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2312   
;;;2313   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L27.30|
000008  bf00              NOP      
00000a  2310              MOVS     r3,#0x10
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L27.28|
00001c  e7fe              B        |L27.28|
                  |L27.30|
;;;2314   	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
00001e  6b93              LDR      r3,[r2,#0x38]
000020  b90b              CBNZ     r3,|L27.38|
;;;2315   	{
;;;2316   		xReturn = pdTRUE;
000022  2001              MOVS     r0,#1
000024  e000              B        |L27.40|
                  |L27.38|
;;;2317   	}
;;;2318   	else
;;;2319   	{
;;;2320   		xReturn = pdFALSE;
000026  2000              MOVS     r0,#0
                  |L27.40|
;;;2321   	}
;;;2322   
;;;2323   	return xReturn;
;;;2324   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000028  bd10              POP      {r4,pc}
;;;2325   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2347   
;;;2348   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;2349   {
000002  4601              MOV      r1,r0
;;;2350   BaseType_t xReturn;
;;;2351   Queue_t * const pxQueue = xQueue;
000004  460a              MOV      r2,r1
;;;2352   
;;;2353   	configASSERT( pxQueue );
000006  b952              CBNZ     r2,|L28.30|
000008  bf00              NOP      
00000a  2310              MOVS     r3,#0x10
00000c  f3838811          MSR      BASEPRI,r3
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  bf00              NOP      
                  |L28.28|
00001c  e7fe              B        |L28.28|
                  |L28.30|
;;;2354   	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
00001e  6b93              LDR      r3,[r2,#0x38]
000020  6bd4              LDR      r4,[r2,#0x3c]
000022  42a3              CMP      r3,r4
000024  d101              BNE      |L28.42|
;;;2355   	{
;;;2356   		xReturn = pdTRUE;
000026  2001              MOVS     r0,#1
000028  e000              B        |L28.44|
                  |L28.42|
;;;2357   	}
;;;2358   	else
;;;2359   	{
;;;2360   		xReturn = pdFALSE;
00002a  2000              MOVS     r0,#0
                  |L28.44|
;;;2361   	}
;;;2362   
;;;2363   	return xReturn;
;;;2364   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00002c  bd10              POP      {r4,pc}
;;;2365   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=2

                  xQueuePeek PROC
;;;1631   
;;;1632   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1633   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;1634   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1635   TimeOut_t xTimeOut;
;;;1636   int8_t *pcOriginalReadPosition;
;;;1637   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1638   
;;;1639   	/* Check the pointer is not NULL. */
;;;1640   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L29.40|
000012  bf00              NOP      
000014  2010              MOVS     r0,#0x10
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L29.38|
000026  e7fe              B        |L29.38|
                  |L29.40|
;;;1641   
;;;1642   	/* The buffer into which data is received can only be NULL if the data size
;;;1643   	is zero (so no data is copied into the buffer. */
;;;1644   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000028  b90e              CBNZ     r6,|L29.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L29.50|
                  |L29.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L29.52|
                  |L29.50|
000032  2000              MOVS     r0,#0
                  |L29.52|
000034  b950              CBNZ     r0,|L29.76|
000036  bf00              NOP      
000038  2010              MOVS     r0,#0x10
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L29.74|
00004a  e7fe              B        |L29.74|
                  |L29.76|
;;;1645   
;;;1646   	/* Cannot block if the scheduler is suspended. */
;;;1647   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1648   	{
;;;1649   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1650   	}
;;;1651   	#endif
;;;1652   
;;;1653   
;;;1654   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1655   	allow return statements within the function itself.  This is done in the
;;;1656   	interest of execution time efficiency. */
;;;1657   	for( ;; )
00004c  bf00              NOP      
                  |L29.78|
;;;1658   	{
;;;1659   		taskENTER_CRITICAL();
00004e  f7fffffe          BL       vPortEnterCritical
;;;1660   		{
;;;1661   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000052  f8d49038          LDR      r9,[r4,#0x38]
;;;1662   
;;;1663   			/* Is there data in the queue now?  To be running the calling task
;;;1664   			must be the highest priority task wanting to access the queue. */
;;;1665   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000056  f1b90f00          CMP      r9,#0
00005a  d01e              BEQ      |L29.154|
;;;1666   			{
;;;1667   				/* Remember the read position so it can be reset after the data
;;;1668   				is read from the queue as this function is only peeking the
;;;1669   				data, not removing it. */
;;;1670   				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
00005c  68e7              LDR      r7,[r4,#0xc]
;;;1671   
;;;1672   				prvCopyDataFromQueue( pxQueue, pvBuffer );
00005e  4631              MOV      r1,r6
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       prvCopyDataFromQueue
;;;1673   				traceQUEUE_PEEK( pxQueue );
;;;1674   
;;;1675   				/* The data is not being removed, so reset the read pointer. */
;;;1676   				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
000066  60e7              STR      r7,[r4,#0xc]
;;;1677   
;;;1678   				/* The data is being left in the queue, so see if there are
;;;1679   				any other tasks waiting for the data. */
;;;1680   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000068  6a60              LDR      r0,[r4,#0x24]
00006a  b908              CBNZ     r0,|L29.112|
00006c  2001              MOVS     r0,#1
00006e  e000              B        |L29.114|
                  |L29.112|
000070  2000              MOVS     r0,#0
                  |L29.114|
000072  b960              CBNZ     r0,|L29.142|
;;;1681   				{
;;;1682   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000074  f1040024          ADD      r0,r4,#0x24
000078  f7fffffe          BL       xTaskRemoveFromEventList
00007c  b138              CBZ      r0,|L29.142|
;;;1683   					{
;;;1684   						/* The task waiting has a higher priority than this task. */
;;;1685   						queueYIELD_IF_USING_PREEMPTION();
00007e  f04f5080          MOV      r0,#0x10000000
000082  4930              LDR      r1,|L29.324|
000084  6008              STR      r0,[r1,#0]
000086  f3bf8f4f          DSB      
00008a  f3bf8f6f          ISB      
                  |L29.142|
;;;1686   					}
;;;1687   					else
;;;1688   					{
;;;1689   						mtCOVERAGE_TEST_MARKER();
;;;1690   					}
;;;1691   				}
;;;1692   				else
;;;1693   				{
;;;1694   					mtCOVERAGE_TEST_MARKER();
;;;1695   				}
;;;1696   
;;;1697   				taskEXIT_CRITICAL();
00008e  f7fffffe          BL       vPortExitCritical
;;;1698   				return pdPASS;
000092  2001              MOVS     r0,#1
                  |L29.148|
;;;1699   			}
;;;1700   			else
;;;1701   			{
;;;1702   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1703   				{
;;;1704   					/* The queue was empty and no block time is specified (or
;;;1705   					the block time has expired) so leave now. */
;;;1706   					taskEXIT_CRITICAL();
;;;1707   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1708   					return errQUEUE_EMPTY;
;;;1709   				}
;;;1710   				else if( xEntryTimeSet == pdFALSE )
;;;1711   				{
;;;1712   					/* The queue was empty and a block time was specified so
;;;1713   					configure the timeout structure ready to enter the blocked
;;;1714   					state. */
;;;1715   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1716   					xEntryTimeSet = pdTRUE;
;;;1717   				}
;;;1718   				else
;;;1719   				{
;;;1720   					/* Entry time was already set. */
;;;1721   					mtCOVERAGE_TEST_MARKER();
;;;1722   				}
;;;1723   			}
;;;1724   		}
;;;1725   		taskEXIT_CRITICAL();
;;;1726   
;;;1727   		/* Interrupts and other tasks can send to and receive from the queue
;;;1728   		now the critical section has been exited. */
;;;1729   
;;;1730   		vTaskSuspendAll();
;;;1731   		prvLockQueue( pxQueue );
;;;1732   
;;;1733   		/* Update the timeout state to see if it has expired yet. */
;;;1734   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1735   		{
;;;1736   			/* Timeout has not expired yet, check to see if there is data in the
;;;1737   			queue now, and if not enter the Blocked state to wait for data. */
;;;1738   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1739   			{
;;;1740   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1741   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1742   				prvUnlockQueue( pxQueue );
;;;1743   				if( xTaskResumeAll() == pdFALSE )
;;;1744   				{
;;;1745   					portYIELD_WITHIN_API();
;;;1746   				}
;;;1747   				else
;;;1748   				{
;;;1749   					mtCOVERAGE_TEST_MARKER();
;;;1750   				}
;;;1751   			}
;;;1752   			else
;;;1753   			{
;;;1754   				/* There is data in the queue now, so don't enter the blocked
;;;1755   				state, instead return to try and obtain the data. */
;;;1756   				prvUnlockQueue( pxQueue );
;;;1757   				( void ) xTaskResumeAll();
;;;1758   			}
;;;1759   		}
;;;1760   		else
;;;1761   		{
;;;1762   			/* The timeout has expired.  If there is still no data in the queue
;;;1763   			exit, otherwise go back and try to read the data again. */
;;;1764   			prvUnlockQueue( pxQueue );
;;;1765   			( void ) xTaskResumeAll();
;;;1766   
;;;1767   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1768   			{
;;;1769   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1770   				return errQUEUE_EMPTY;
;;;1771   			}
;;;1772   			else
;;;1773   			{
;;;1774   				mtCOVERAGE_TEST_MARKER();
;;;1775   			}
;;;1776   		}
;;;1777   	} /*lint -restore */
;;;1778   }
000094  b005              ADD      sp,sp,#0x14
000096  e8bd83f0          POP      {r4-r9,pc}
                  |L29.154|
00009a  9804              LDR      r0,[sp,#0x10]         ;1702
00009c  b918              CBNZ     r0,|L29.166|
00009e  f7fffffe          BL       vPortExitCritical
0000a2  2000              MOVS     r0,#0                 ;1708
0000a4  e7f6              B        |L29.148|
                  |L29.166|
0000a6  f1b80f00          CMP      r8,#0                 ;1710
0000aa  d104              BNE      |L29.182|
0000ac  4668              MOV      r0,sp                 ;1715
0000ae  f7fffffe          BL       vTaskInternalSetTimeOutState
0000b2  f04f0801          MOV      r8,#1                 ;1716
                  |L29.182|
0000b6  f7fffffe          BL       vPortExitCritical
0000ba  f7fffffe          BL       vTaskSuspendAll
0000be  f7fffffe          BL       vPortEnterCritical
0000c2  f9940044          LDRSB    r0,[r4,#0x44]         ;1731
0000c6  1c40              ADDS     r0,r0,#1              ;1731
0000c8  b910              CBNZ     r0,|L29.208|
0000ca  2000              MOVS     r0,#0                 ;1731
0000cc  f8840044          STRB     r0,[r4,#0x44]         ;1731
                  |L29.208|
0000d0  f9940045          LDRSB    r0,[r4,#0x45]         ;1731
0000d4  1c40              ADDS     r0,r0,#1              ;1731
0000d6  b910              CBNZ     r0,|L29.222|
0000d8  2000              MOVS     r0,#0                 ;1731
0000da  f8840045          STRB     r0,[r4,#0x45]         ;1731
                  |L29.222|
0000de  f7fffffe          BL       vPortExitCritical
0000e2  a904              ADD      r1,sp,#0x10           ;1734
0000e4  4668              MOV      r0,sp                 ;1734
0000e6  f7fffffe          BL       xTaskCheckForTimeOut
0000ea  b9f0              CBNZ     r0,|L29.298|
0000ec  4620              MOV      r0,r4                 ;1738
0000ee  f7fffffe          BL       prvIsQueueEmpty
0000f2  b1a0              CBZ      r0,|L29.286|
0000f4  f1040024          ADD      r0,r4,#0x24           ;1741
0000f8  9904              LDR      r1,[sp,#0x10]         ;1741
0000fa  f7fffffe          BL       vTaskPlaceOnEventList
0000fe  4620              MOV      r0,r4                 ;1742
000100  f7fffffe          BL       prvUnlockQueue
000104  f7fffffe          BL       xTaskResumeAll
000108  2800              CMP      r0,#0                 ;1743
00010a  d1a0              BNE      |L29.78|
00010c  f04f5080          MOV      r0,#0x10000000        ;1745
000110  490c              LDR      r1,|L29.324|
000112  6008              STR      r0,[r1,#0]            ;1745
000114  f3bf8f4f          DSB                            ;1745
000118  f3bf8f6f          ISB                            ;1745
00011c  e797              B        |L29.78|
                  |L29.286|
00011e  4620              MOV      r0,r4                 ;1756
000120  f7fffffe          BL       prvUnlockQueue
000124  f7fffffe          BL       xTaskResumeAll
000128  e791              B        |L29.78|
                  |L29.298|
00012a  4620              MOV      r0,r4                 ;1764
00012c  f7fffffe          BL       prvUnlockQueue
000130  f7fffffe          BL       xTaskResumeAll
000134  4620              MOV      r0,r4                 ;1767
000136  f7fffffe          BL       prvIsQueueEmpty
00013a  2800              CMP      r0,#0                 ;1767
00013c  d087              BEQ      |L29.78|
00013e  2000              MOVS     r0,#0                 ;1770
000140  e7a8              B        |L29.148|
;;;1779   /*-----------------------------------------------------------*/
                          ENDP

000142  0000              DCW      0x0000
                  |L29.324|
                          DCD      0xe000ed04

                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1871   
;;;1872   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1873   {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;1874   BaseType_t xReturn;
;;;1875   UBaseType_t uxSavedInterruptStatus;
;;;1876   int8_t *pcOriginalReadPosition;
;;;1877   Queue_t * const pxQueue = xQueue;
000008  4634              MOV      r4,r6
;;;1878   
;;;1879   	configASSERT( pxQueue );
00000a  b954              CBNZ     r4,|L30.34|
00000c  bf00              NOP      
00000e  2010              MOVS     r0,#0x10
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L30.32|
000020  e7fe              B        |L30.32|
                  |L30.34|
;;;1880   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000022  f1b80f00          CMP      r8,#0
000026  d101              BNE      |L30.44|
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b908              CBNZ     r0,|L30.48|
                  |L30.44|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L30.50|
                  |L30.48|
000030  2000              MOVS     r0,#0
                  |L30.50|
000032  b950              CBNZ     r0,|L30.74|
000034  bf00              NOP      
000036  2010              MOVS     r0,#0x10
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L30.72|
000048  e7fe              B        |L30.72|
                  |L30.74|
;;;1881   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
00004a  6c20              LDR      r0,[r4,#0x40]
00004c  b108              CBZ      r0,|L30.82|
00004e  2001              MOVS     r0,#1
000050  e000              B        |L30.84|
                  |L30.82|
000052  2000              MOVS     r0,#0
                  |L30.84|
000054  b950              CBNZ     r0,|L30.108|
000056  bf00              NOP      
000058  2010              MOVS     r0,#0x10
00005a  f3808811          MSR      BASEPRI,r0
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
000066  bf00              NOP      
000068  bf00              NOP      
                  |L30.106|
00006a  e7fe              B        |L30.106|
                  |L30.108|
;;;1882   
;;;1883   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1884   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1885   	above the maximum system call priority are kept permanently enabled, even
;;;1886   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1887   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1888   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1889   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1890   	assigned a priority above the configured maximum system call priority.
;;;1891   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1892   	that have been assigned a priority at or (logically) below the maximum
;;;1893   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1894   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1895   	More information (albeit Cortex-M specific) is provided on the following
;;;1896   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1897   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00006c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1898   
;;;1899   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000070  bf00              NOP      
000072  2110              MOVS     r1,#0x10
000074  f3ef8011          MRS      r0,BASEPRI
000078  f3818811          MSR      BASEPRI,r1
00007c  f3bf8f4f          DSB      
000080  f3bf8f6f          ISB      
000084  bf00              NOP      
000086  4605              MOV      r5,r0
;;;1900   	{
;;;1901   		/* Cannot block in an ISR, so check there is data available. */
;;;1902   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
000088  6ba0              LDR      r0,[r4,#0x38]
00008a  b148              CBZ      r0,|L30.160|
;;;1903   		{
;;;1904   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1905   
;;;1906   			/* Remember the read position so it can be reset as nothing is
;;;1907   			actually being removed from the queue. */
;;;1908   			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
00008c  f8d4900c          LDR      r9,[r4,#0xc]
;;;1909   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000090  4641              MOV      r1,r8
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       prvCopyDataFromQueue
;;;1910   			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
000098  f8c4900c          STR      r9,[r4,#0xc]
;;;1911   
;;;1912   			xReturn = pdPASS;
00009c  2701              MOVS     r7,#1
00009e  e000              B        |L30.162|
                  |L30.160|
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			xReturn = pdFAIL;
0000a0  2700              MOVS     r7,#0
                  |L30.162|
;;;1917   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1918   		}
;;;1919   	}
;;;1920   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a2  bf00              NOP      
0000a4  f3858811          MSR      BASEPRI,r5
0000a8  bf00              NOP      
;;;1921   
;;;1922   	return xReturn;
0000aa  4638              MOV      r0,r7
;;;1923   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1924   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=2

                  xQueueReceive PROC
;;;1272   
;;;1273   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;1274   {
000004  b083              SUB      sp,sp,#0xc
000006  4605              MOV      r5,r0
000008  460e              MOV      r6,r1
;;;1275   BaseType_t xEntryTimeSet = pdFALSE;
00000a  f04f0800          MOV      r8,#0
;;;1276   TimeOut_t xTimeOut;
;;;1277   Queue_t * const pxQueue = xQueue;
00000e  462c              MOV      r4,r5
;;;1278   
;;;1279   	/* Check the pointer is not NULL. */
;;;1280   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L31.40|
000012  bf00              NOP      
000014  2010              MOVS     r0,#0x10
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L31.38|
000026  e7fe              B        |L31.38|
                  |L31.40|
;;;1281   
;;;1282   	/* The buffer into which data is received can only be NULL if the data size
;;;1283   	is zero (so no data is copied into the buffer. */
;;;1284   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
000028  b90e              CBNZ     r6,|L31.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L31.50|
                  |L31.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L31.52|
                  |L31.50|
000032  2000              MOVS     r0,#0
                  |L31.52|
000034  b950              CBNZ     r0,|L31.76|
000036  bf00              NOP      
000038  2010              MOVS     r0,#0x10
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L31.74|
00004a  e7fe              B        |L31.74|
                  |L31.76|
;;;1285   
;;;1286   	/* Cannot block if the scheduler is suspended. */
;;;1287   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1288   	{
;;;1289   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1290   	}
;;;1291   	#endif
;;;1292   
;;;1293   
;;;1294   	/*lint -save -e904  This function relaxes the coding standard somewhat to
;;;1295   	allow return statements within the function itself.  This is done in the
;;;1296   	interest of execution time efficiency. */
;;;1297   	for( ;; )
00004c  bf00              NOP      
                  |L31.78|
;;;1298   	{
;;;1299   		taskENTER_CRITICAL();
00004e  f7fffffe          BL       vPortEnterCritical
;;;1300   		{
;;;1301   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000052  6ba7              LDR      r7,[r4,#0x38]
;;;1302   
;;;1303   			/* Is there data in the queue now?  To be running the calling task
;;;1304   			must be the highest priority task wanting to access the queue. */
;;;1305   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000054  b1f7              CBZ      r7,|L31.148|
;;;1306   			{
;;;1307   				/* Data available, remove one item. */
;;;1308   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000056  4631              MOV      r1,r6
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       prvCopyDataFromQueue
;;;1309   				traceQUEUE_RECEIVE( pxQueue );
;;;1310   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00005e  1e78              SUBS     r0,r7,#1
000060  63a0              STR      r0,[r4,#0x38]
;;;1311   
;;;1312   				/* There is now space in the queue, were any tasks waiting to
;;;1313   				post to the queue?  If so, unblock the highest priority waiting
;;;1314   				task. */
;;;1315   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000062  6920              LDR      r0,[r4,#0x10]
000064  b908              CBNZ     r0,|L31.106|
000066  2001              MOVS     r0,#1
000068  e000              B        |L31.108|
                  |L31.106|
00006a  2000              MOVS     r0,#0
                  |L31.108|
00006c  b960              CBNZ     r0,|L31.136|
;;;1316   				{
;;;1317   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00006e  f1040010          ADD      r0,r4,#0x10
000072  f7fffffe          BL       xTaskRemoveFromEventList
000076  b138              CBZ      r0,|L31.136|
;;;1318   					{
;;;1319   						queueYIELD_IF_USING_PREEMPTION();
000078  f04f5080          MOV      r0,#0x10000000
00007c  492f              LDR      r1,|L31.316|
00007e  6008              STR      r0,[r1,#0]
000080  f3bf8f4f          DSB      
000084  f3bf8f6f          ISB      
                  |L31.136|
;;;1320   					}
;;;1321   					else
;;;1322   					{
;;;1323   						mtCOVERAGE_TEST_MARKER();
;;;1324   					}
;;;1325   				}
;;;1326   				else
;;;1327   				{
;;;1328   					mtCOVERAGE_TEST_MARKER();
;;;1329   				}
;;;1330   
;;;1331   				taskEXIT_CRITICAL();
000088  f7fffffe          BL       vPortExitCritical
;;;1332   				return pdPASS;
00008c  2001              MOVS     r0,#1
                  |L31.142|
;;;1333   			}
;;;1334   			else
;;;1335   			{
;;;1336   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1337   				{
;;;1338   					/* The queue was empty and no block time is specified (or
;;;1339   					the block time has expired) so leave now. */
;;;1340   					taskEXIT_CRITICAL();
;;;1341   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1342   					return errQUEUE_EMPTY;
;;;1343   				}
;;;1344   				else if( xEntryTimeSet == pdFALSE )
;;;1345   				{
;;;1346   					/* The queue was empty and a block time was specified so
;;;1347   					configure the timeout structure. */
;;;1348   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1349   					xEntryTimeSet = pdTRUE;
;;;1350   				}
;;;1351   				else
;;;1352   				{
;;;1353   					/* Entry time was already set. */
;;;1354   					mtCOVERAGE_TEST_MARKER();
;;;1355   				}
;;;1356   			}
;;;1357   		}
;;;1358   		taskEXIT_CRITICAL();
;;;1359   
;;;1360   		/* Interrupts and other tasks can send to and receive from the queue
;;;1361   		now the critical section has been exited. */
;;;1362   
;;;1363   		vTaskSuspendAll();
;;;1364   		prvLockQueue( pxQueue );
;;;1365   
;;;1366   		/* Update the timeout state to see if it has expired yet. */
;;;1367   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1368   		{
;;;1369   			/* The timeout has not expired.  If the queue is still empty place
;;;1370   			the task on the list of tasks waiting to receive from the queue. */
;;;1371   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1372   			{
;;;1373   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1374   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1375   				prvUnlockQueue( pxQueue );
;;;1376   				if( xTaskResumeAll() == pdFALSE )
;;;1377   				{
;;;1378   					portYIELD_WITHIN_API();
;;;1379   				}
;;;1380   				else
;;;1381   				{
;;;1382   					mtCOVERAGE_TEST_MARKER();
;;;1383   				}
;;;1384   			}
;;;1385   			else
;;;1386   			{
;;;1387   				/* The queue contains data again.  Loop back to try and read the
;;;1388   				data. */
;;;1389   				prvUnlockQueue( pxQueue );
;;;1390   				( void ) xTaskResumeAll();
;;;1391   			}
;;;1392   		}
;;;1393   		else
;;;1394   		{
;;;1395   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1396   			back and attempt to read the data. */
;;;1397   			prvUnlockQueue( pxQueue );
;;;1398   			( void ) xTaskResumeAll();
;;;1399   
;;;1400   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1401   			{
;;;1402   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1403   				return errQUEUE_EMPTY;
;;;1404   			}
;;;1405   			else
;;;1406   			{
;;;1407   				mtCOVERAGE_TEST_MARKER();
;;;1408   			}
;;;1409   		}
;;;1410   	} /*lint -restore */
;;;1411   }
00008e  b006              ADD      sp,sp,#0x18
000090  e8bd81f0          POP      {r4-r8,pc}
                  |L31.148|
000094  9805              LDR      r0,[sp,#0x14]         ;1336
000096  b918              CBNZ     r0,|L31.160|
000098  f7fffffe          BL       vPortExitCritical
00009c  2000              MOVS     r0,#0                 ;1342
00009e  e7f6              B        |L31.142|
                  |L31.160|
0000a0  f1b80f00          CMP      r8,#0                 ;1344
0000a4  d104              BNE      |L31.176|
0000a6  a801              ADD      r0,sp,#4              ;1348
0000a8  f7fffffe          BL       vTaskInternalSetTimeOutState
0000ac  f04f0801          MOV      r8,#1                 ;1349
                  |L31.176|
0000b0  f7fffffe          BL       vPortExitCritical
0000b4  f7fffffe          BL       vTaskSuspendAll
0000b8  f7fffffe          BL       vPortEnterCritical
0000bc  f9940044          LDRSB    r0,[r4,#0x44]         ;1364
0000c0  1c40              ADDS     r0,r0,#1              ;1364
0000c2  b910              CBNZ     r0,|L31.202|
0000c4  2000              MOVS     r0,#0                 ;1364
0000c6  f8840044          STRB     r0,[r4,#0x44]         ;1364
                  |L31.202|
0000ca  f9940045          LDRSB    r0,[r4,#0x45]         ;1364
0000ce  1c40              ADDS     r0,r0,#1              ;1364
0000d0  b910              CBNZ     r0,|L31.216|
0000d2  2000              MOVS     r0,#0                 ;1364
0000d4  f8840045          STRB     r0,[r4,#0x45]         ;1364
                  |L31.216|
0000d8  f7fffffe          BL       vPortExitCritical
0000dc  a905              ADD      r1,sp,#0x14           ;1367
0000de  a801              ADD      r0,sp,#4              ;1367
0000e0  f7fffffe          BL       xTaskCheckForTimeOut
0000e4  b9f0              CBNZ     r0,|L31.292|
0000e6  4620              MOV      r0,r4                 ;1371
0000e8  f7fffffe          BL       prvIsQueueEmpty
0000ec  b1a0              CBZ      r0,|L31.280|
0000ee  f1040024          ADD      r0,r4,#0x24           ;1374
0000f2  9905              LDR      r1,[sp,#0x14]         ;1374
0000f4  f7fffffe          BL       vTaskPlaceOnEventList
0000f8  4620              MOV      r0,r4                 ;1375
0000fa  f7fffffe          BL       prvUnlockQueue
0000fe  f7fffffe          BL       xTaskResumeAll
000102  2800              CMP      r0,#0                 ;1376
000104  d1a3              BNE      |L31.78|
000106  f04f5080          MOV      r0,#0x10000000        ;1378
00010a  490c              LDR      r1,|L31.316|
00010c  6008              STR      r0,[r1,#0]            ;1378
00010e  f3bf8f4f          DSB                            ;1378
000112  f3bf8f6f          ISB                            ;1378
000116  e79a              B        |L31.78|
                  |L31.280|
000118  4620              MOV      r0,r4                 ;1389
00011a  f7fffffe          BL       prvUnlockQueue
00011e  f7fffffe          BL       xTaskResumeAll
000122  e794              B        |L31.78|
                  |L31.292|
000124  4620              MOV      r0,r4                 ;1397
000126  f7fffffe          BL       prvUnlockQueue
00012a  f7fffffe          BL       xTaskResumeAll
00012e  4620              MOV      r0,r4                 ;1400
000130  f7fffffe          BL       prvIsQueueEmpty
000134  2800              CMP      r0,#0                 ;1400
000136  d08a              BEQ      |L31.78|
000138  2000              MOVS     r0,#0                 ;1403
00013a  e7a8              B        |L31.142|
;;;1412   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.316|
                          DCD      0xe000ed04

                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1780   
;;;1781   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1782   {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4617              MOV      r7,r2
;;;1783   BaseType_t xReturn;
;;;1784   UBaseType_t uxSavedInterruptStatus;
;;;1785   Queue_t * const pxQueue = xQueue;
00000a  4634              MOV      r4,r6
;;;1786   
;;;1787   	configASSERT( pxQueue );
00000c  b954              CBNZ     r4,|L32.36|
00000e  bf00              NOP      
000010  2010              MOVS     r0,#0x10
000012  f3808811          MSR      BASEPRI,r0
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L32.34|
000022  e7fe              B        |L32.34|
                  |L32.36|
;;;1788   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000024  f1b90f00          CMP      r9,#0
000028  d101              BNE      |L32.46|
00002a  6c20              LDR      r0,[r4,#0x40]
00002c  b908              CBNZ     r0,|L32.50|
                  |L32.46|
00002e  2001              MOVS     r0,#1
000030  e000              B        |L32.52|
                  |L32.50|
000032  2000              MOVS     r0,#0
                  |L32.52|
000034  b950              CBNZ     r0,|L32.76|
000036  bf00              NOP      
000038  2010              MOVS     r0,#0x10
00003a  f3808811          MSR      BASEPRI,r0
00003e  f3bf8f4f          DSB      
000042  f3bf8f6f          ISB      
000046  bf00              NOP      
000048  bf00              NOP      
                  |L32.74|
00004a  e7fe              B        |L32.74|
                  |L32.76|
;;;1789   
;;;1790   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1791   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1792   	above the maximum system call priority are kept permanently enabled, even
;;;1793   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1794   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1795   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1796   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1797   	assigned a priority above the configured maximum system call priority.
;;;1798   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1799   	that have been assigned a priority at or (logically) below the maximum
;;;1800   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1801   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1802   	More information (albeit Cortex-M specific) is provided on the following
;;;1803   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1804   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00004c  f7fffffe          BL       vPortValidateInterruptPriority
;;;1805   
;;;1806   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000050  bf00              NOP      
000052  2110              MOVS     r1,#0x10
000054  f3ef8011          MRS      r0,BASEPRI
000058  f3818811          MSR      BASEPRI,r1
00005c  f3bf8f4f          DSB      
000060  f3bf8f6f          ISB      
000064  bf00              NOP      
000066  4605              MOV      r5,r0
;;;1807   	{
;;;1808   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000068  f8d4a038          LDR      r10,[r4,#0x38]
;;;1809   
;;;1810   		/* Cannot block in an ISR, so check there is data available. */
;;;1811   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00006c  f1ba0f00          CMP      r10,#0
000070  d022              BEQ      |L32.184|
;;;1812   		{
;;;1813   			const int8_t cRxLock = pxQueue->cRxLock;
000072  f994b044          LDRSB    r11,[r4,#0x44]
;;;1814   
;;;1815   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1816   
;;;1817   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000076  4649              MOV      r1,r9
000078  4620              MOV      r0,r4
00007a  f7fffffe          BL       prvCopyDataFromQueue
;;;1818   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00007e  f1aa0001          SUB      r0,r10,#1
000082  63a0              STR      r0,[r4,#0x38]
;;;1819   
;;;1820   			/* If the queue is locked the event list will not be modified.
;;;1821   			Instead update the lock count so the task that unlocks the queue
;;;1822   			will know that an ISR has removed data while the queue was
;;;1823   			locked. */
;;;1824   			if( cRxLock == queueUNLOCKED )
000084  f10b0001          ADD      r0,r11,#1
000088  b970              CBNZ     r0,|L32.168|
;;;1825   			{
;;;1826   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00008a  6920              LDR      r0,[r4,#0x10]
00008c  b908              CBNZ     r0,|L32.146|
00008e  2001              MOVS     r0,#1
000090  e000              B        |L32.148|
                  |L32.146|
000092  2000              MOVS     r0,#0
                  |L32.148|
000094  b968              CBNZ     r0,|L32.178|
;;;1827   				{
;;;1828   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000096  f1040010          ADD      r0,r4,#0x10
00009a  f7fffffe          BL       xTaskRemoveFromEventList
00009e  b140              CBZ      r0,|L32.178|
;;;1829   					{
;;;1830   						/* The task waiting has a higher priority than us so
;;;1831   						force a context switch. */
;;;1832   						if( pxHigherPriorityTaskWoken != NULL )
0000a0  b13f              CBZ      r7,|L32.178|
;;;1833   						{
;;;1834   							*pxHigherPriorityTaskWoken = pdTRUE;
0000a2  2001              MOVS     r0,#1
0000a4  6038              STR      r0,[r7,#0]
0000a6  e004              B        |L32.178|
                  |L32.168|
;;;1835   						}
;;;1836   						else
;;;1837   						{
;;;1838   							mtCOVERAGE_TEST_MARKER();
;;;1839   						}
;;;1840   					}
;;;1841   					else
;;;1842   					{
;;;1843   						mtCOVERAGE_TEST_MARKER();
;;;1844   					}
;;;1845   				}
;;;1846   				else
;;;1847   				{
;;;1848   					mtCOVERAGE_TEST_MARKER();
;;;1849   				}
;;;1850   			}
;;;1851   			else
;;;1852   			{
;;;1853   				/* Increment the lock count so the task that unlocks the queue
;;;1854   				knows that data was removed while it was locked. */
;;;1855   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
0000a8  f10b0001          ADD      r0,r11,#1
0000ac  b240              SXTB     r0,r0
0000ae  f8840044          STRB     r0,[r4,#0x44]
                  |L32.178|
;;;1856   			}
;;;1857   
;;;1858   			xReturn = pdPASS;
0000b2  f04f0801          MOV      r8,#1
;;;1859   		}
0000b6  e001              B        |L32.188|
                  |L32.184|
;;;1860   		else
;;;1861   		{
;;;1862   			xReturn = pdFAIL;
0000b8  f04f0800          MOV      r8,#0
                  |L32.188|
;;;1863   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1864   		}
;;;1865   	}
;;;1866   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000bc  bf00              NOP      
0000be  f3858811          MSR      BASEPRI,r5
0000c2  bf00              NOP      
;;;1867   
;;;1868   	return xReturn;
0000c4  4640              MOV      r0,r8
;;;1869   }
0000c6  e8bd9ff0          POP      {r4-r12,pc}
;;;1870   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=2

                  xQueueSemaphoreTake PROC
;;;1413   
;;;1414   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1415   {
000004  b082              SUB      sp,sp,#8
000006  4605              MOV      r5,r0
;;;1416   BaseType_t xEntryTimeSet = pdFALSE;
000008  f04f0800          MOV      r8,#0
;;;1417   TimeOut_t xTimeOut;
;;;1418   Queue_t * const pxQueue = xQueue;
00000c  462c              MOV      r4,r5
;;;1419   
;;;1420   #if( configUSE_MUTEXES == 1 )
;;;1421   	BaseType_t xInheritanceOccurred = pdFALSE;
00000e  2600              MOVS     r6,#0
;;;1422   #endif
;;;1423   
;;;1424   	/* Check the queue pointer is not NULL. */
;;;1425   	configASSERT( ( pxQueue ) );
000010  b954              CBNZ     r4,|L33.40|
000012  bf00              NOP      
000014  2010              MOVS     r0,#0x10
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L33.38|
000026  e7fe              B        |L33.38|
                  |L33.40|
;;;1426   
;;;1427   	/* Check this really is a semaphore, in which case the item size will be
;;;1428   	0. */
;;;1429   	configASSERT( pxQueue->uxItemSize == 0 );
000028  6c20              LDR      r0,[r4,#0x40]
00002a  b908              CBNZ     r0,|L33.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L33.50|
                  |L33.48|
000030  2000              MOVS     r0,#0
                  |L33.50|
000032  b950              CBNZ     r0,|L33.74|
000034  bf00              NOP      
000036  2010              MOVS     r0,#0x10
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L33.72|
000048  e7fe              B        |L33.72|
                  |L33.74|
;;;1430   
;;;1431   	/* Cannot block if the scheduler is suspended. */
;;;1432   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1433   	{
;;;1434   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1435   	}
;;;1436   	#endif
;;;1437   
;;;1438   
;;;1439   	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
;;;1440   	statements within the function itself.  This is done in the interest
;;;1441   	of execution time efficiency. */
;;;1442   	for( ;; )
00004a  bf00              NOP      
                  |L33.76|
;;;1443   	{
;;;1444   		taskENTER_CRITICAL();
00004c  f7fffffe          BL       vPortEnterCritical
;;;1445   		{
;;;1446   			/* Semaphores are queues with an item size of 0, and where the
;;;1447   			number of messages in the queue is the semaphore's count value. */
;;;1448   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000050  6ba7              LDR      r7,[r4,#0x38]
;;;1449   
;;;1450   			/* Is there data in the queue now?  To be running the calling task
;;;1451   			must be the highest priority task wanting to access the queue. */
;;;1452   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
000052  b1ff              CBZ      r7,|L33.148|
;;;1453   			{
;;;1454   				traceQUEUE_RECEIVE( pxQueue );
;;;1455   
;;;1456   				/* Semaphores are queues with a data size of zero and where the
;;;1457   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1458   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
000054  1e78              SUBS     r0,r7,#1
000056  63a0              STR      r0,[r4,#0x38]
;;;1459   
;;;1460   				#if ( configUSE_MUTEXES == 1 )
;;;1461   				{
;;;1462   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000058  6820              LDR      r0,[r4,#0]
00005a  b910              CBNZ     r0,|L33.98|
;;;1463   					{
;;;1464   						/* Record the information required to implement
;;;1465   						priority inheritance should it become necessary. */
;;;1466   						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
00005c  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000060  60a0              STR      r0,[r4,#8]
                  |L33.98|
;;;1467   					}
;;;1468   					else
;;;1469   					{
;;;1470   						mtCOVERAGE_TEST_MARKER();
;;;1471   					}
;;;1472   				}
;;;1473   				#endif /* configUSE_MUTEXES */
;;;1474   
;;;1475   				/* Check to see if other tasks are blocked waiting to give the
;;;1476   				semaphore, and if so, unblock the highest priority such task. */
;;;1477   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000062  6920              LDR      r0,[r4,#0x10]
000064  b908              CBNZ     r0,|L33.106|
000066  2001              MOVS     r0,#1
000068  e000              B        |L33.108|
                  |L33.106|
00006a  2000              MOVS     r0,#0
                  |L33.108|
00006c  b960              CBNZ     r0,|L33.136|
;;;1478   				{
;;;1479   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00006e  f1040010          ADD      r0,r4,#0x10
000072  f7fffffe          BL       xTaskRemoveFromEventList
000076  b138              CBZ      r0,|L33.136|
;;;1480   					{
;;;1481   						queueYIELD_IF_USING_PREEMPTION();
000078  f04f5080          MOV      r0,#0x10000000
00007c  4943              LDR      r1,|L33.396|
00007e  6008              STR      r0,[r1,#0]
000080  f3bf8f4f          DSB      
000084  f3bf8f6f          ISB      
                  |L33.136|
;;;1482   					}
;;;1483   					else
;;;1484   					{
;;;1485   						mtCOVERAGE_TEST_MARKER();
;;;1486   					}
;;;1487   				}
;;;1488   				else
;;;1489   				{
;;;1490   					mtCOVERAGE_TEST_MARKER();
;;;1491   				}
;;;1492   
;;;1493   				taskEXIT_CRITICAL();
000088  f7fffffe          BL       vPortExitCritical
;;;1494   				return pdPASS;
00008c  2001              MOVS     r0,#1
                  |L33.142|
;;;1495   			}
;;;1496   			else
;;;1497   			{
;;;1498   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1499   				{
;;;1500   					/* For inheritance to have occurred there must have been an
;;;1501   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1502   					if it were 0 the function would have exited. */
;;;1503   					#if( configUSE_MUTEXES == 1 )
;;;1504   					{
;;;1505   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1506   					}
;;;1507   					#endif /* configUSE_MUTEXES */
;;;1508   
;;;1509   					/* The semaphore count was 0 and no block time is specified
;;;1510   					(or the block time has expired) so exit now. */
;;;1511   					taskEXIT_CRITICAL();
;;;1512   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1513   					return errQUEUE_EMPTY;
;;;1514   				}
;;;1515   				else if( xEntryTimeSet == pdFALSE )
;;;1516   				{
;;;1517   					/* The semaphore count was 0 and a block time was specified
;;;1518   					so configure the timeout structure ready to block. */
;;;1519   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1520   					xEntryTimeSet = pdTRUE;
;;;1521   				}
;;;1522   				else
;;;1523   				{
;;;1524   					/* Entry time was already set. */
;;;1525   					mtCOVERAGE_TEST_MARKER();
;;;1526   				}
;;;1527   			}
;;;1528   		}
;;;1529   		taskEXIT_CRITICAL();
;;;1530   
;;;1531   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1532   		now the critical section has been exited. */
;;;1533   
;;;1534   		vTaskSuspendAll();
;;;1535   		prvLockQueue( pxQueue );
;;;1536   
;;;1537   		/* Update the timeout state to see if it has expired yet. */
;;;1538   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1539   		{
;;;1540   			/* A block time is specified and not expired.  If the semaphore
;;;1541   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1542   			become available.  As semaphores are implemented with queues the
;;;1543   			queue being empty is equivalent to the semaphore count being 0. */
;;;1544   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1545   			{
;;;1546   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1547   
;;;1548   				#if ( configUSE_MUTEXES == 1 )
;;;1549   				{
;;;1550   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1551   					{
;;;1552   						taskENTER_CRITICAL();
;;;1553   						{
;;;1554   							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
;;;1555   						}
;;;1556   						taskEXIT_CRITICAL();
;;;1557   					}
;;;1558   					else
;;;1559   					{
;;;1560   						mtCOVERAGE_TEST_MARKER();
;;;1561   					}
;;;1562   				}
;;;1563   				#endif
;;;1564   
;;;1565   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1566   				prvUnlockQueue( pxQueue );
;;;1567   				if( xTaskResumeAll() == pdFALSE )
;;;1568   				{
;;;1569   					portYIELD_WITHIN_API();
;;;1570   				}
;;;1571   				else
;;;1572   				{
;;;1573   					mtCOVERAGE_TEST_MARKER();
;;;1574   				}
;;;1575   			}
;;;1576   			else
;;;1577   			{
;;;1578   				/* There was no timeout and the semaphore count was not 0, so
;;;1579   				attempt to take the semaphore again. */
;;;1580   				prvUnlockQueue( pxQueue );
;;;1581   				( void ) xTaskResumeAll();
;;;1582   			}
;;;1583   		}
;;;1584   		else
;;;1585   		{
;;;1586   			/* Timed out. */
;;;1587   			prvUnlockQueue( pxQueue );
;;;1588   			( void ) xTaskResumeAll();
;;;1589   
;;;1590   			/* If the semaphore count is 0 exit now as the timeout has
;;;1591   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1592   			known to be available.  As semaphores are implemented by queues the
;;;1593   			queue being empty is equivalent to the semaphore count being 0. */
;;;1594   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1595   			{
;;;1596   				#if ( configUSE_MUTEXES == 1 )
;;;1597   				{
;;;1598   					/* xInheritanceOccurred could only have be set if
;;;1599   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1600   					test the mutex type again to check it is actually a mutex. */
;;;1601   					if( xInheritanceOccurred != pdFALSE )
;;;1602   					{
;;;1603   						taskENTER_CRITICAL();
;;;1604   						{
;;;1605   							UBaseType_t uxHighestWaitingPriority;
;;;1606   
;;;1607   							/* This task blocking on the mutex caused another
;;;1608   							task to inherit this task's priority.  Now this task
;;;1609   							has timed out the priority should be disinherited
;;;1610   							again, but only as low as the next highest priority
;;;1611   							task that is waiting for the same mutex. */
;;;1612   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1613   							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
;;;1614   						}
;;;1615   						taskEXIT_CRITICAL();
;;;1616   					}
;;;1617   				}
;;;1618   				#endif /* configUSE_MUTEXES */
;;;1619   
;;;1620   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1621   				return errQUEUE_EMPTY;
;;;1622   			}
;;;1623   			else
;;;1624   			{
;;;1625   				mtCOVERAGE_TEST_MARKER();
;;;1626   			}
;;;1627   		}
;;;1628   	} /*lint -restore */
;;;1629   }
00008e  b004              ADD      sp,sp,#0x10
000090  e8bd81f0          POP      {r4-r8,pc}
                  |L33.148|
000094  9803              LDR      r0,[sp,#0xc]          ;1498
000096  b998              CBNZ     r0,|L33.192|
000098  b90e              CBNZ     r6,|L33.158|
00009a  2001              MOVS     r0,#1                 ;1505
00009c  e000              B        |L33.160|
                  |L33.158|
00009e  2000              MOVS     r0,#0                 ;1505
                  |L33.160|
0000a0  b950              CBNZ     r0,|L33.184|
0000a2  bf00              NOP                            ;1505
0000a4  2010              MOVS     r0,#0x10              ;1505
0000a6  f3808811          MSR      BASEPRI,r0            ;1505
0000aa  f3bf8f4f          DSB                            ;1505
0000ae  f3bf8f6f          ISB                            ;1505
0000b2  bf00              NOP                            ;1505
0000b4  bf00              NOP                            ;1505
                  |L33.182|
0000b6  e7fe              B        |L33.182|
                  |L33.184|
0000b8  f7fffffe          BL       vPortExitCritical
0000bc  2000              MOVS     r0,#0                 ;1513
0000be  e7e6              B        |L33.142|
                  |L33.192|
0000c0  f1b80f00          CMP      r8,#0                 ;1515
0000c4  d104              BNE      |L33.208|
0000c6  4668              MOV      r0,sp                 ;1519
0000c8  f7fffffe          BL       vTaskInternalSetTimeOutState
0000cc  f04f0801          MOV      r8,#1                 ;1520
                  |L33.208|
0000d0  f7fffffe          BL       vPortExitCritical
0000d4  f7fffffe          BL       vTaskSuspendAll
0000d8  f7fffffe          BL       vPortEnterCritical
0000dc  f9940044          LDRSB    r0,[r4,#0x44]         ;1535
0000e0  1c40              ADDS     r0,r0,#1              ;1535
0000e2  b910              CBNZ     r0,|L33.234|
0000e4  2000              MOVS     r0,#0                 ;1535
0000e6  f8840044          STRB     r0,[r4,#0x44]         ;1535
                  |L33.234|
0000ea  f9940045          LDRSB    r0,[r4,#0x45]         ;1535
0000ee  1c40              ADDS     r0,r0,#1              ;1535
0000f0  b910              CBNZ     r0,|L33.248|
0000f2  2000              MOVS     r0,#0                 ;1535
0000f4  f8840045          STRB     r0,[r4,#0x45]         ;1535
                  |L33.248|
0000f8  f7fffffe          BL       vPortExitCritical
0000fc  a903              ADD      r1,sp,#0xc            ;1538
0000fe  4668              MOV      r0,sp                 ;1538
000100  f7fffffe          BL       xTaskCheckForTimeOut
000104  bb40              CBNZ     r0,|L33.344|
000106  4620              MOV      r0,r4                 ;1544
000108  f7fffffe          BL       prvIsQueueEmpty
00010c  b1f0              CBZ      r0,|L33.332|
00010e  6820              LDR      r0,[r4,#0]            ;1550
000110  b938              CBNZ     r0,|L33.290|
000112  f7fffffe          BL       vPortEnterCritical
000116  68a0              LDR      r0,[r4,#8]            ;1554
000118  f7fffffe          BL       xTaskPriorityInherit
00011c  4606              MOV      r6,r0                 ;1554
00011e  f7fffffe          BL       vPortExitCritical
                  |L33.290|
000122  f1040024          ADD      r0,r4,#0x24           ;1565
000126  9903              LDR      r1,[sp,#0xc]          ;1565
000128  f7fffffe          BL       vTaskPlaceOnEventList
00012c  4620              MOV      r0,r4                 ;1566
00012e  f7fffffe          BL       prvUnlockQueue
000132  f7fffffe          BL       xTaskResumeAll
000136  2800              CMP      r0,#0                 ;1567
000138  d188              BNE      |L33.76|
00013a  f04f5080          MOV      r0,#0x10000000        ;1569
00013e  4913              LDR      r1,|L33.396|
000140  6008              STR      r0,[r1,#0]            ;1569
000142  f3bf8f4f          DSB                            ;1569
000146  f3bf8f6f          ISB                            ;1569
                  |L33.330|
00014a  e77f              B        |L33.76|
                  |L33.332|
00014c  4620              MOV      r0,r4                 ;1580
00014e  f7fffffe          BL       prvUnlockQueue
000152  f7fffffe          BL       xTaskResumeAll
000156  e779              B        |L33.76|
                  |L33.344|
000158  4620              MOV      r0,r4                 ;1587
00015a  f7fffffe          BL       prvUnlockQueue
00015e  f7fffffe          BL       xTaskResumeAll
000162  4620              MOV      r0,r4                 ;1594
000164  f7fffffe          BL       prvIsQueueEmpty
000168  2800              CMP      r0,#0                 ;1594
00016a  d0ee              BEQ      |L33.330|
00016c  b15e              CBZ      r6,|L33.390|
00016e  f7fffffe          BL       vPortEnterCritical
000172  4620              MOV      r0,r4                 ;1612
000174  f7fffffe          BL       prvGetDisinheritPriorityAfterTimeout
000178  4607              MOV      r7,r0                 ;1612
00017a  4639              MOV      r1,r7                 ;1613
00017c  68a0              LDR      r0,[r4,#8]            ;1613
00017e  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
000182  f7fffffe          BL       vPortExitCritical
                  |L33.390|
000186  2000              MOVS     r0,#0                 ;1621
000188  e781              B        |L33.142|
;;;1630   /*-----------------------------------------------------------*/
                          ENDP

00018a  0000              DCW      0x0000
                  |L33.396|
                          DCD      0xe000ed04

                          AREA ||i.xQueueTakeMutexRecursive||, CODE, READONLY, ALIGN=1

                  xQueueTakeMutexRecursive PROC
;;;650    
;;;651    	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;652    	{
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;653    	BaseType_t xReturn;
;;;654    	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
000008  4634              MOV      r4,r6
;;;655    
;;;656    		configASSERT( pxMutex );
00000a  b954              CBNZ     r4,|L34.34|
00000c  bf00              NOP      
00000e  2010              MOVS     r0,#0x10
000010  f3808811          MSR      BASEPRI,r0
000014  f3bf8f4f          DSB      
000018  f3bf8f6f          ISB      
00001c  bf00              NOP      
00001e  bf00              NOP      
                  |L34.32|
000020  e7fe              B        |L34.32|
                  |L34.34|
;;;657    
;;;658    		/* Comments regarding mutual exclusion as per those within
;;;659    		xQueueGiveMutexRecursive(). */
;;;660    
;;;661    		traceTAKE_MUTEX_RECURSIVE( pxMutex );
;;;662    
;;;663    		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
000022  f7fffffe          BL       xTaskGetCurrentTaskHandle
000026  68a1              LDR      r1,[r4,#8]
000028  4288              CMP      r0,r1
00002a  d104              BNE      |L34.54|
;;;664    		{
;;;665    			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  1c40              ADDS     r0,r0,#1
000030  60e0              STR      r0,[r4,#0xc]
;;;666    			xReturn = pdPASS;
000032  2501              MOVS     r5,#1
000034  e008              B        |L34.72|
                  |L34.54|
;;;667    		}
;;;668    		else
;;;669    		{
;;;670    			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
000036  4639              MOV      r1,r7
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       xQueueSemaphoreTake
00003e  4605              MOV      r5,r0
;;;671    
;;;672    			/* pdPASS will only be returned if the mutex was successfully
;;;673    			obtained.  The calling task may have entered the Blocked state
;;;674    			before reaching here. */
;;;675    			if( xReturn != pdFAIL )
000040  b115              CBZ      r5,|L34.72|
;;;676    			{
;;;677    				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
000042  68e0              LDR      r0,[r4,#0xc]
000044  1c40              ADDS     r0,r0,#1
000046  60e0              STR      r0,[r4,#0xc]
                  |L34.72|
;;;678    			}
;;;679    			else
;;;680    			{
;;;681    				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
;;;682    			}
;;;683    		}
;;;684    
;;;685    		return xReturn;
000048  4628              MOV      r0,r5
;;;686    	}
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;687    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        64
