; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\port.o --asm_dir=.\Flash\ --list_dir=.\Flash\ --depend=.\flash\obj\port.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\bsp -I..\User\bsp\inc -I..\User -I..\..\Libraries\CMSIS\Include -I..\..\FreeRTOS\include -I..\..\FreeRTOS\portable\RVDS\ARM_CM3 -I.\RTE\_Flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\port.crf ..\..\FreeRTOS\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;410    
;;;411    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;412    {
;;;413    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;414    	executes all interrupts must be unmasked.  There is therefore no need to
;;;415    	save and then restore the interrupt mask value as its value is already
;;;416    	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
;;;417    	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
;;;418    	vPortRaiseBASEPRI();
000002  bf00              NOP      
000004  2010              MOVS     r0,#0x10
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;419    	{
;;;420    		/* Increment the RTOS tick. */
;;;421    		if( xTaskIncrementTick() != pdFALSE )
000014  f7fffffe          BL       xTaskIncrementTick
000018  b118              CBZ      r0,|L1.34|
;;;422    		{
;;;423    			/* A context switch is required.  Context switching is performed in
;;;424    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;425    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00001a  f04f5080          MOV      r0,#0x10000000
00001e  4904              LDR      r1,|L1.48|
000020  6008              STR      r0,[r1,#0]
                  |L1.34|
;;;426    		}
;;;427    	}
;;;428    	vPortClearBASEPRIFromISR();
000022  bf00              NOP      
000024  2000              MOVS     r0,#0
000026  f3808811          MSR      BASEPRI,r0
00002a  bf00              NOP      
;;;429    }
00002c  bd10              POP      {r4,pc}
;;;430    /*-----------------------------------------------------------*/
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      0xe000ed04

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                  prvTaskExitError PROC
;;;193    
;;;194    static void prvTaskExitError( void )
000000  480e              LDR      r0,|L2.60|
;;;195    {
;;;196    	/* A function that implements a task must not exit or attempt to return to
;;;197    	its caller as there is nothing to return to.  If a task wants to exit it
;;;198    	should instead call vTaskDelete( NULL ).
;;;199    
;;;200    	Artificially force an assert() to be triggered if configASSERT() is
;;;201    	defined, then stop here so application writers can catch the error. */
;;;202    	configASSERT( uxCriticalNesting == ~0UL );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  b908              CBNZ     r0,|L2.12|
000008  2001              MOVS     r0,#1
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  2000              MOVS     r0,#0
                  |L2.14|
00000e  b950              CBNZ     r0,|L2.38|
000010  bf00              NOP      
000012  2010              MOVS     r0,#0x10
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L2.36|
000024  e7fe              B        |L2.36|
                  |L2.38|
;;;203    	portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  2010              MOVS     r0,#0x10
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;204    	for( ;; );
000038  bf00              NOP      
                  |L2.58|
00003a  e7fe              B        |L2.58|
;;;205    }
;;;206    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.60|
                          DCD      uxCriticalNesting

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;174     */
;;;175    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  1f00              SUBS     r0,r0,#4
;;;176    {
;;;177    	/* Simulate the stack frame as it would be created by a context switch
;;;178    	interrupt. */
;;;179    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;180    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  f04f7380          MOV      r3,#0x1000000
000006  6003              STR      r3,[r0,#0]
;;;181    	pxTopOfStack--;
000008  1f00              SUBS     r0,r0,#4
;;;182    	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
00000a  f0210301          BIC      r3,r1,#1
00000e  6003              STR      r3,[r0,#0]
;;;183    	pxTopOfStack--;
000010  1f00              SUBS     r0,r0,#4
;;;184    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
000012  4b03              LDR      r3,|L3.32|
000014  6003              STR      r3,[r0,#0]
;;;185    
;;;186    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
000016  3814              SUBS     r0,r0,#0x14
;;;187    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
000018  6002              STR      r2,[r0,#0]
;;;188    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
00001a  3820              SUBS     r0,r0,#0x20
;;;189    
;;;190    	return pxTopOfStack;
;;;191    }
00001c  4770              BX       lr
;;;192    /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                  vPortEndScheduler PROC
;;;337    
;;;338    void vPortEndScheduler( void )
000000  480a              LDR      r0,|L4.44|
;;;339    {
;;;340    	/* Not implemented in ports where there is nothing to return to.
;;;341    	Artificially force an assert. */
;;;342    	configASSERT( uxCriticalNesting == 1000UL );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  f5b07f7a          CMP      r0,#0x3e8
000008  d101              BNE      |L4.14|
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L4.16|
                  |L4.14|
00000e  2000              MOVS     r0,#0
                  |L4.16|
000010  b950              CBNZ     r0,|L4.40|
000012  bf00              NOP      
000014  2010              MOVS     r0,#0x10
000016  f3808811          MSR      BASEPRI,r0
00001a  f3bf8f4f          DSB      
00001e  f3bf8f6f          ISB      
000022  bf00              NOP      
000024  bf00              NOP      
                  |L4.38|
000026  e7fe              B        |L4.38|
                  |L4.40|
;;;343    }
000028  4770              BX       lr
;;;344    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;345    
;;;346    void vPortEnterCritical( void )
000000  bf00              NOP      
000002  2010              MOVS     r0,#0x10
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
000010  bf00              NOP      
;;;347    {
;;;348    	portDISABLE_INTERRUPTS();
;;;349    	uxCriticalNesting++;
000012  480e              LDR      r0,|L5.76|
000014  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000016  1c40              ADDS     r0,r0,#1
000018  490c              LDR      r1,|L5.76|
00001a  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;350    
;;;351    	/* This is not the interrupt safe version of the enter critical function so
;;;352    	assert() if it is being called from an interrupt context.  Only API
;;;353    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;354    	the critical nesting count is 1 to protect against recursive calls if the
;;;355    	assert function also uses a critical section. */
;;;356    	if( uxCriticalNesting == 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000020  2801              CMP      r0,#1
000022  d112              BNE      |L5.74|
;;;357    	{
;;;358    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
000024  480a              LDR      r0,|L5.80|
000026  6800              LDR      r0,[r0,#0]
000028  b2c0              UXTB     r0,r0
00002a  b908              CBNZ     r0,|L5.48|
00002c  2001              MOVS     r0,#1
00002e  e000              B        |L5.50|
                  |L5.48|
000030  2000              MOVS     r0,#0
                  |L5.50|
000032  b950              CBNZ     r0,|L5.74|
000034  bf00              NOP      
000036  2010              MOVS     r0,#0x10
000038  f3808811          MSR      BASEPRI,r0
00003c  f3bf8f4f          DSB      
000040  f3bf8f6f          ISB      
000044  bf00              NOP      
000046  bf00              NOP      
                  |L5.72|
000048  e7fe              B        |L5.72|
                  |L5.74|
;;;359    	}
;;;360    }
00004a  4770              BX       lr
;;;361    /*-----------------------------------------------------------*/
                          ENDP

                  |L5.76|
                          DCD      uxCriticalNesting
                  |L5.80|
                          DCD      0xe000ed04

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;362    
;;;363    void vPortExitCritical( void )
000000  480d              LDR      r0,|L6.56|
;;;364    {
;;;365    	configASSERT( uxCriticalNesting );
000002  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000004  b950              CBNZ     r0,|L6.28|
000006  bf00              NOP      
000008  2010              MOVS     r0,#0x10
00000a  f3808811          MSR      BASEPRI,r0
00000e  f3bf8f4f          DSB      
000012  f3bf8f6f          ISB      
000016  bf00              NOP      
000018  bf00              NOP      
                  |L6.26|
00001a  e7fe              B        |L6.26|
                  |L6.28|
;;;366    	uxCriticalNesting--;
00001c  4806              LDR      r0,|L6.56|
00001e  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000020  1e40              SUBS     r0,r0,#1
000022  4905              LDR      r1,|L6.56|
000024  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;367    	if( uxCriticalNesting == 0 )
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00002a  b920              CBNZ     r0,|L6.54|
;;;368    	{
;;;369    		portENABLE_INTERRUPTS();
00002c  2000              MOVS     r0,#0
00002e  f3808811          MSR      BASEPRI,r0
000032  bf00              NOP      
000034  bf00              NOP      
                  |L6.54|
;;;370    	}
;;;371    }
000036  4770              BX       lr
;;;372    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.56|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;605    
;;;606    	void vPortSetupTimerInterrupt( void )
000000  4815              LDR      r0,|L7.88|
;;;607    	{
;;;608    		/* Calculate the constants required to configure the tick interrupt. */
;;;609    		#if( configUSE_TICKLESS_IDLE == 1 )
;;;610    		{
;;;611    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
000002  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000004  f44f717a          MOV      r1,#0x3e8
000008  fbb0f0f1          UDIV     r0,r0,r1
00000c  4913              LDR      r1,|L7.92|
00000e  6008              STR      r0,[r1,#0]  ; ulTimerCountsForOneTick
;;;612    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
000010  4608              MOV      r0,r1
000012  6800              LDR      r0,[r0,#0]  ; ulTimerCountsForOneTick
000014  f06f417f          MVN      r1,#0xff000000
000018  fbb1f0f0          UDIV     r0,r1,r0
00001c  4910              LDR      r1,|L7.96|
00001e  6008              STR      r0,[r1,#0]  ; xMaximumPossibleSuppressedTicks
;;;613    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
000020  480d              LDR      r0,|L7.88|
000022  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000024  fbb0f0f0          UDIV     r0,r0,r0
000028  212d              MOVS     r1,#0x2d
00002a  fbb1f0f0          UDIV     r0,r1,r0
00002e  490d              LDR      r1,|L7.100|
000030  6008              STR      r0,[r1,#0]  ; ulStoppedTimerCompensation
;;;614    		}
;;;615    		#endif /* configUSE_TICKLESS_IDLE */
;;;616    
;;;617    		/* Stop and clear the SysTick. */
;;;618    		portNVIC_SYSTICK_CTRL_REG = 0UL;
000032  2000              MOVS     r0,#0
000034  f04f21e0          MOV      r1,#0xe000e000
000038  6108              STR      r0,[r1,#0x10]
;;;619    		portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
00003a  6188              STR      r0,[r1,#0x18]
;;;620    
;;;621    		/* Configure SysTick to interrupt at the requested rate. */
;;;622    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
00003c  4806              LDR      r0,|L7.88|
00003e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000040  f44f717a          MOV      r1,#0x3e8
000044  fbb0f0f1          UDIV     r0,r0,r1
000048  1e40              SUBS     r0,r0,#1
00004a  f04f21e0          MOV      r1,#0xe000e000
00004e  6148              STR      r0,[r1,#0x14]
;;;623    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
000050  2007              MOVS     r0,#7
000052  6108              STR      r0,[r1,#0x10]
;;;624    	}
000054  4770              BX       lr
;;;625    
                          ENDP

000056  0000              DCW      0x0000
                  |L7.88|
                          DCD      SystemCoreClock
                  |L7.92|
                          DCD      ulTimerCountsForOneTick
                  |L7.96|
                          DCD      xMaximumPossibleSuppressedTicks
                  |L7.100|
                          DCD      ulStoppedTimerCompensation

                          AREA ||i.vPortSuppressTicksAndSleep||, CODE, READONLY, ALIGN=2

                  vPortSuppressTicksAndSleep PROC
;;;433    
;;;434    	__weak void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;435    	{
000004  4604              MOV      r4,r0
;;;436    	uint32_t ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
;;;437    	TickType_t xModifiableIdleTime;
;;;438    
;;;439    		/* Make sure the SysTick reload value does not overflow the counter. */
;;;440    		if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
000006  4851              LDR      r0,|L8.332|
000008  6800              LDR      r0,[r0,#0]  ; xMaximumPossibleSuppressedTicks
00000a  4284              CMP      r4,r0
00000c  d901              BLS      |L8.18|
;;;441    		{
;;;442    			xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
00000e  484f              LDR      r0,|L8.332|
000010  6804              LDR      r4,[r0,#0]  ; xMaximumPossibleSuppressedTicks
                  |L8.18|
;;;443    		}
;;;444    
;;;445    		/* Stop the SysTick momentarily.  The time the SysTick is stopped for
;;;446    		is accounted for as best it can be, but using the tickless mode will
;;;447    		inevitably result in some tiny drift of the time maintained by the
;;;448    		kernel with respect to calendar time. */
;;;449    		portNVIC_SYSTICK_CTRL_REG &= ~portNVIC_SYSTICK_ENABLE_BIT;
000012  f04f20e0          MOV      r0,#0xe000e000
000016  6900              LDR      r0,[r0,#0x10]
000018  f0200001          BIC      r0,r0,#1
00001c  f04f21e0          MOV      r1,#0xe000e000
000020  6108              STR      r0,[r1,#0x10]
;;;450    
;;;451    		/* Calculate the reload value required to wait xExpectedIdleTime
;;;452    		tick periods.  -1 is used because this code will execute part way
;;;453    		through one of the tick periods. */
;;;454    		ulReloadValue = portNVIC_SYSTICK_CURRENT_VALUE_REG + ( ulTimerCountsForOneTick * ( xExpectedIdleTime - 1UL ) );
000022  4608              MOV      r0,r1
000024  6981              LDR      r1,[r0,#0x18]
000026  1e60              SUBS     r0,r4,#1
000028  4a49              LDR      r2,|L8.336|
00002a  6812              LDR      r2,[r2,#0]  ; ulTimerCountsForOneTick
00002c  fb021500          MLA      r5,r2,r0,r1
;;;455    		if( ulReloadValue > ulStoppedTimerCompensation )
000030  4848              LDR      r0,|L8.340|
000032  6800              LDR      r0,[r0,#0]  ; ulStoppedTimerCompensation
000034  4285              CMP      r5,r0
000036  d902              BLS      |L8.62|
;;;456    		{
;;;457    			ulReloadValue -= ulStoppedTimerCompensation;
000038  4846              LDR      r0,|L8.340|
00003a  6800              LDR      r0,[r0,#0]  ; ulStoppedTimerCompensation
00003c  1a2d              SUBS     r5,r5,r0
                  |L8.62|
;;;458    		}
;;;459    
;;;460    		/* Enter a critical section but don't use the taskENTER_CRITICAL()
;;;461    		method as that will mask interrupts that should exit sleep mode. */
;;;462    		__disable_irq();
00003e  b672              CPSID    i
;;;463    		__dsb( portSY_FULL_READ_WRITE );
000040  f3bf8f4f          DSB      
;;;464    		__isb( portSY_FULL_READ_WRITE );
000044  f3bf8f6f          ISB      
;;;465    
;;;466    		/* If a context switch is pending or a task is waiting for the scheduler
;;;467    		to be unsuspended then abandon the low power entry. */
;;;468    		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
000048  f7fffffe          BL       eTaskConfirmSleepModeStatus
00004c  b980              CBNZ     r0,|L8.112|
;;;469    		{
;;;470    			/* Restart from whatever is left in the count register to complete
;;;471    			this tick period. */
;;;472    			portNVIC_SYSTICK_LOAD_REG = portNVIC_SYSTICK_CURRENT_VALUE_REG;
00004e  f04f20e0          MOV      r0,#0xe000e000
000052  6980              LDR      r0,[r0,#0x18]
000054  f04f21e0          MOV      r1,#0xe000e000
000058  6148              STR      r0,[r1,#0x14]
;;;473    
;;;474    			/* Restart SysTick. */
;;;475    			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
00005a  4608              MOV      r0,r1
00005c  6900              LDR      r0,[r0,#0x10]
00005e  f0400001          ORR      r0,r0,#1
000062  6108              STR      r0,[r1,#0x10]
;;;476    
;;;477    			/* Reset the reload register to the value required for normal tick
;;;478    			periods. */
;;;479    			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
000064  483a              LDR      r0,|L8.336|
000066  6800              LDR      r0,[r0,#0]  ; ulTimerCountsForOneTick
000068  1e40              SUBS     r0,r0,#1
00006a  6148              STR      r0,[r1,#0x14]
;;;480    
;;;481    			/* Re-enable interrupts - see comments above __disable_irq() call
;;;482    			above. */
;;;483    			__enable_irq();
00006c  b662              CPSIE    i
00006e  e06b              B        |L8.328|
                  |L8.112|
;;;484    		}
;;;485    		else
;;;486    		{
;;;487    			/* Set the new reload value. */
;;;488    			portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
000070  f04f20e0          MOV      r0,#0xe000e000
000074  6145              STR      r5,[r0,#0x14]
;;;489    
;;;490    			/* Clear the SysTick count flag and set the count value back to
;;;491    			zero. */
;;;492    			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
000076  2000              MOVS     r0,#0
000078  f04f21e0          MOV      r1,#0xe000e000
00007c  6188              STR      r0,[r1,#0x18]
;;;493    
;;;494    			/* Restart SysTick. */
;;;495    			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
00007e  4608              MOV      r0,r1
000080  6900              LDR      r0,[r0,#0x10]
000082  f0400001          ORR      r0,r0,#1
000086  6108              STR      r0,[r1,#0x10]
;;;496    
;;;497    			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
;;;498    			set its parameter to 0 to indicate that its implementation contains
;;;499    			its own wait for interrupt or wait for event instruction, and so wfi
;;;500    			should not be executed again.  However, the original expected idle
;;;501    			time variable must remain unmodified, so a copy is taken. */
;;;502    			xModifiableIdleTime = xExpectedIdleTime;
000088  46a0              MOV      r8,r4
;;;503    			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
00008a  4640              MOV      r0,r8
00008c  f7fffffe          BL       OS_PreSleepProcessing
;;;504    			if( xModifiableIdleTime > 0 )
000090  f1b80f00          CMP      r8,#0
000094  d004              BEQ      |L8.160|
;;;505    			{
;;;506    				__dsb( portSY_FULL_READ_WRITE );
000096  f3bf8f4f          DSB      
;;;507    				__wfi();
00009a  bf30              WFI      
;;;508    				__isb( portSY_FULL_READ_WRITE );
00009c  f3bf8f6f          ISB      
                  |L8.160|
;;;509    			}
;;;510    			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       OS_PostSleepProcessing
;;;511    
;;;512    			/* Re-enable interrupts to allow the interrupt that brought the MCU
;;;513    			out of sleep mode to execute immediately.  see comments above
;;;514    			__disable_interrupt() call above. */
;;;515    			__enable_irq();
0000a6  b662              CPSIE    i
;;;516    			__dsb( portSY_FULL_READ_WRITE );
0000a8  f3bf8f4f          DSB      
;;;517    			__isb( portSY_FULL_READ_WRITE );
0000ac  f3bf8f6f          ISB      
;;;518    
;;;519    			/* Disable interrupts again because the clock is about to be stopped
;;;520    			and interrupts that execute while the clock is stopped will increase
;;;521    			any slippage between the time maintained by the RTOS and calendar
;;;522    			time. */
;;;523    			__disable_irq();
0000b0  b672              CPSID    i
;;;524    			__dsb( portSY_FULL_READ_WRITE );
0000b2  f3bf8f4f          DSB      
;;;525    			__isb( portSY_FULL_READ_WRITE );
0000b6  f3bf8f6f          ISB      
;;;526    			
;;;527    			/* Disable the SysTick clock without reading the 
;;;528    			portNVIC_SYSTICK_CTRL_REG register to ensure the
;;;529    			portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again, 
;;;530    			the time the SysTick is stopped for is accounted for as best it can 
;;;531    			be, but using the tickless mode will inevitably result in some tiny 
;;;532    			drift of the time maintained by the kernel with respect to calendar 
;;;533    			time*/
;;;534    			portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT );
0000ba  2006              MOVS     r0,#6
0000bc  f04f21e0          MOV      r1,#0xe000e000
0000c0  6108              STR      r0,[r1,#0x10]
;;;535    
;;;536    			/* Determine if the SysTick clock has already counted to zero and
;;;537    			been set back to the current reload value (the reload back being
;;;538    			correct for the entire expected idle time) or if the SysTick is yet
;;;539    			to count to zero (in which case an interrupt other than the SysTick
;;;540    			must have brought the system out of sleep mode). */
;;;541    			if( ( portNVIC_SYSTICK_CTRL_REG & portNVIC_SYSTICK_COUNT_FLAG_BIT ) != 0 )
0000c2  4608              MOV      r0,r1
0000c4  6900              LDR      r0,[r0,#0x10]
0000c6  f4003080          AND      r0,r0,#0x10000
0000ca  b1b8              CBZ      r0,|L8.252|
;;;542    			{
;;;543    				uint32_t ulCalculatedLoadValue;
;;;544    
;;;545    				/* The tick interrupt is already pending, and the SysTick count
;;;546    				reloaded with ulReloadValue.  Reset the
;;;547    				portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
;;;548    				period. */
;;;549    				ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL ) - ( ulReloadValue - portNVIC_SYSTICK_CURRENT_VALUE_REG );
0000cc  4920              LDR      r1,|L8.336|
0000ce  6809              LDR      r1,[r1,#0]  ; ulTimerCountsForOneTick
0000d0  1e49              SUBS     r1,r1,#1
0000d2  f04f22e0          MOV      r2,#0xe000e000
0000d6  6992              LDR      r2,[r2,#0x18]
0000d8  1aaa              SUBS     r2,r5,r2
0000da  1a88              SUBS     r0,r1,r2
;;;550    
;;;551    				/* Don't allow a tiny value, or values that have somehow
;;;552    				underflowed because the post sleep hook did something
;;;553    				that took too long. */
;;;554    				if( ( ulCalculatedLoadValue < ulStoppedTimerCompensation ) || ( ulCalculatedLoadValue > ulTimerCountsForOneTick ) )
0000dc  491d              LDR      r1,|L8.340|
0000de  6809              LDR      r1,[r1,#0]  ; ulStoppedTimerCompensation
0000e0  4288              CMP      r0,r1
0000e2  d303              BCC      |L8.236|
0000e4  491a              LDR      r1,|L8.336|
0000e6  6809              LDR      r1,[r1,#0]  ; ulTimerCountsForOneTick
0000e8  4288              CMP      r0,r1
0000ea  d902              BLS      |L8.242|
                  |L8.236|
;;;555    				{
;;;556    					ulCalculatedLoadValue = ( ulTimerCountsForOneTick - 1UL );
0000ec  4918              LDR      r1,|L8.336|
0000ee  6809              LDR      r1,[r1,#0]  ; ulTimerCountsForOneTick
0000f0  1e48              SUBS     r0,r1,#1
                  |L8.242|
;;;557    				}
;;;558    
;;;559    				portNVIC_SYSTICK_LOAD_REG = ulCalculatedLoadValue;
0000f2  f04f21e0          MOV      r1,#0xe000e000
0000f6  6148              STR      r0,[r1,#0x14]
;;;560    
;;;561    				/* As the pending tick will be processed as soon as this
;;;562    				function exits, the tick value maintained by the tick is stepped
;;;563    				forward by one less than the time spent waiting. */
;;;564    				ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
0000f8  1e66              SUBS     r6,r4,#1
;;;565    			}
0000fa  e012              B        |L8.290|
                  |L8.252|
;;;566    			else
;;;567    			{
;;;568    				/* Something other than the tick interrupt ended the sleep.
;;;569    				Work out how long the sleep lasted rounded to complete tick
;;;570    				periods (not the ulReload value which accounted for part
;;;571    				ticks). */
;;;572    				ulCompletedSysTickDecrements = ( xExpectedIdleTime * ulTimerCountsForOneTick ) - portNVIC_SYSTICK_CURRENT_VALUE_REG;
0000fc  4814              LDR      r0,|L8.336|
0000fe  6800              LDR      r0,[r0,#0]  ; ulTimerCountsForOneTick
000100  4360              MULS     r0,r4,r0
000102  f04f21e0          MOV      r1,#0xe000e000
000106  6989              LDR      r1,[r1,#0x18]
000108  1a47              SUBS     r7,r0,r1
;;;573    
;;;574    				/* How many complete tick periods passed while the processor
;;;575    				was waiting? */
;;;576    				ulCompleteTickPeriods = ulCompletedSysTickDecrements / ulTimerCountsForOneTick;
00010a  4811              LDR      r0,|L8.336|
00010c  6800              LDR      r0,[r0,#0]  ; ulTimerCountsForOneTick
00010e  fbb7f6f0          UDIV     r6,r7,r0
;;;577    
;;;578    				/* The reload value is set to whatever fraction of a single tick
;;;579    				period remains. */
;;;580    				portNVIC_SYSTICK_LOAD_REG = ( ( ulCompleteTickPeriods + 1UL ) * ulTimerCountsForOneTick ) - ulCompletedSysTickDecrements;
000112  1c70              ADDS     r0,r6,#1
000114  490e              LDR      r1,|L8.336|
000116  6809              LDR      r1,[r1,#0]  ; ulTimerCountsForOneTick
000118  4348              MULS     r0,r1,r0
00011a  1bc0              SUBS     r0,r0,r7
00011c  f04f21e0          MOV      r1,#0xe000e000
000120  6148              STR      r0,[r1,#0x14]
                  |L8.290|
;;;581    			}
;;;582    
;;;583    			/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
;;;584    			again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
;;;585    			value. */
;;;586    			portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
000122  2000              MOVS     r0,#0
000124  f04f21e0          MOV      r1,#0xe000e000
000128  6188              STR      r0,[r1,#0x18]
;;;587    			portNVIC_SYSTICK_CTRL_REG |= portNVIC_SYSTICK_ENABLE_BIT;
00012a  4608              MOV      r0,r1
00012c  6900              LDR      r0,[r0,#0x10]
00012e  f0400001          ORR      r0,r0,#1
000132  6108              STR      r0,[r1,#0x10]
;;;588    			vTaskStepTick( ulCompleteTickPeriods );
000134  4630              MOV      r0,r6
000136  f7fffffe          BL       vTaskStepTick
;;;589    			portNVIC_SYSTICK_LOAD_REG = ulTimerCountsForOneTick - 1UL;
00013a  4805              LDR      r0,|L8.336|
00013c  6800              LDR      r0,[r0,#0]  ; ulTimerCountsForOneTick
00013e  1e40              SUBS     r0,r0,#1
000140  f04f21e0          MOV      r1,#0xe000e000
000144  6148              STR      r0,[r1,#0x14]
;;;590    
;;;591    			/* Exit with interrpts enabled. */
;;;592    			__enable_irq();
000146  b662              CPSIE    i
                  |L8.328|
;;;593    		}
;;;594    	}
000148  e8bd81f0          POP      {r4-r8,pc}
;;;595    
                          ENDP

                  |L8.332|
                          DCD      xMaximumPossibleSuppressedTicks
                  |L8.336|
                          DCD      ulTimerCountsForOneTick
                  |L8.340|
                          DCD      ulStoppedTimerCompensation

                          AREA ||i.vPortValidateInterruptPriority||, CODE, READONLY, ALIGN=2

                  vPortValidateInterruptPriority PROC
;;;639    
;;;640    	void vPortValidateInterruptPriority( void )
000000  b570              PUSH     {r4-r6,lr}
;;;641    	{
;;;642    	uint32_t ulCurrentInterrupt;
;;;643    	uint8_t ucCurrentPriority;
;;;644    
;;;645    		/* Obtain the number of the currently executing interrupt. */
;;;646    		ulCurrentInterrupt = vPortGetIPSR();
000002  f7fffffe          BL       vPortGetIPSR
000006  4604              MOV      r4,r0
;;;647    
;;;648    		/* Is the interrupt number a user defined interrupt? */
;;;649    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
000008  2c10              CMP      r4,#0x10
00000a  d316              BCC      |L9.58|
;;;650    		{
;;;651    			/* Look up the interrupt's priority. */
;;;652    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
00000c  f10420e0          ADD      r0,r4,#0xe000e000
000010  f89053f0          LDRB     r5,[r0,#0x3f0]
;;;653    
;;;654    			/* The following assertion will fail if a service routine (ISR) for
;;;655    			an interrupt that has been assigned a priority above
;;;656    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;657    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;658    			from interrupts that have been assigned a priority at or below
;;;659    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;660    
;;;661    			Numerically low interrupt priority numbers represent logically high
;;;662    			interrupt priorities, therefore the priority of the interrupt must
;;;663    			be set to a value equal to or numerically *higher* than
;;;664    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;665    
;;;666    			Interrupts that	use the FreeRTOS API must not be left at their
;;;667    			default priority of	zero as that is the highest possible priority,
;;;668    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;669    			and	therefore also guaranteed to be invalid.
;;;670    
;;;671    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;672    			interrupt entry is as fast and simple as possible.
;;;673    
;;;674    			The following links provide detailed information:
;;;675    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;676    			http://www.freertos.org/FAQHelp.html */
;;;677    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
000014  4815              LDR      r0,|L9.108|
000016  7800              LDRB     r0,[r0,#0]  ; ucMaxSysCallPriority
000018  4285              CMP      r5,r0
00001a  db01              BLT      |L9.32|
00001c  2001              MOVS     r0,#1
00001e  e000              B        |L9.34|
                  |L9.32|
000020  2000              MOVS     r0,#0
                  |L9.34|
000022  b950              CBNZ     r0,|L9.58|
000024  bf00              NOP      
000026  2010              MOVS     r0,#0x10
000028  f3808811          MSR      BASEPRI,r0
00002c  f3bf8f4f          DSB      
000030  f3bf8f6f          ISB      
000034  bf00              NOP      
000036  bf00              NOP      
                  |L9.56|
000038  e7fe              B        |L9.56|
                  |L9.58|
;;;678    		}
;;;679    
;;;680    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;681    		that define each interrupt's priority to be split between bits that
;;;682    		define the interrupt's pre-emption priority bits and bits that define
;;;683    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;684    		to be pre-emption priority bits.  The following assertion will fail if
;;;685    		this is not the case (if some bits represent a sub-priority).
;;;686    
;;;687    		If the application only uses CMSIS libraries for interrupt
;;;688    		configuration then the correct setting can be achieved on all Cortex-M
;;;689    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;690    		scheduler.  Note however that some vendor specific peripheral libraries
;;;691    		assume a non-zero priority group setting, in which cases using a value
;;;692    		of zero will result in unpredictable behaviour. */
;;;693    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
00003a  480d              LDR      r0,|L9.112|
00003c  6800              LDR      r0,[r0,#0]
00003e  f40060e0          AND      r0,r0,#0x700
000042  490c              LDR      r1,|L9.116|
000044  6809              LDR      r1,[r1,#0]  ; ulMaxPRIGROUPValue
000046  4288              CMP      r0,r1
000048  d801              BHI      |L9.78|
00004a  2001              MOVS     r0,#1
00004c  e000              B        |L9.80|
                  |L9.78|
00004e  2000              MOVS     r0,#0
                  |L9.80|
000050  b950              CBNZ     r0,|L9.104|
000052  bf00              NOP      
000054  2010              MOVS     r0,#0x10
000056  f3808811          MSR      BASEPRI,r0
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  bf00              NOP      
000064  bf00              NOP      
                  |L9.102|
000066  e7fe              B        |L9.102|
                  |L9.104|
;;;694    	}
000068  bd70              POP      {r4-r6,pc}
;;;695    
                          ENDP

00006a  0000              DCW      0x0000
                  |L9.108|
                          DCD      ucMaxSysCallPriority
                  |L9.112|
                          DCD      0xe000ed0c
                  |L9.116|
                          DCD      ulMaxPRIGROUPValue

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;250     */
;;;251    BaseType_t xPortStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;252    {
;;;253    	#if( configASSERT_DEFINED == 1 )
;;;254    	{
;;;255    		volatile uint32_t ulOriginalPriority;
;;;256    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000002  4938              LDR      r1,|L10.228|
;;;257    		volatile uint8_t ucMaxPriorityValue;
;;;258    
;;;259    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;260    		functions can be called.  ISR safe functions are those that end in
;;;261    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;262    		ensure interrupt entry is as fast and simple as possible.
;;;263    
;;;264    		Save the interrupt priority value that is about to be clobbered. */
;;;265    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000004  4608              MOV      r0,r1
000006  7800              LDRB     r0,[r0,#0]
000008  9001              STR      r0,[sp,#4]
;;;266    
;;;267    		/* Determine the number of priority bits available.  First write to all
;;;268    		possible bits. */
;;;269    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
00000a  20ff              MOVS     r0,#0xff
00000c  460a              MOV      r2,r1
00000e  7010              STRB     r0,[r2,#0]
;;;270    
;;;271    		/* Read the value back to see how many bits stuck. */
;;;272    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
000010  4608              MOV      r0,r1
000012  7800              LDRB     r0,[r0,#0]
000014  9000              STR      r0,[sp,#0]
;;;273    
;;;274    		/* The kernel interrupt priority should be set to the lowest
;;;275    		priority. */
;;;276    		configASSERT( ucMaxPriorityValue == ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) );
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  f00000f0          AND      r0,r0,#0xf0
00001e  f89d2000          LDRB     r2,[sp,#0]
000022  4290              CMP      r0,r2
000024  d101              BNE      |L10.42|
000026  2001              MOVS     r0,#1
000028  e000              B        |L10.44|
                  |L10.42|
00002a  2000              MOVS     r0,#0
                  |L10.44|
00002c  b950              CBNZ     r0,|L10.68|
00002e  bf00              NOP      
000030  2010              MOVS     r0,#0x10
000032  f3808811          MSR      BASEPRI,r0
000036  f3bf8f4f          DSB      
00003a  f3bf8f6f          ISB      
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L10.66|
000042  e7fe              B        |L10.66|
                  |L10.68|
;;;277    
;;;278    		/* Use the same mask on the maximum system call priority. */
;;;279    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000044  f89d0000          LDRB     r0,[sp,#0]
000048  f0000010          AND      r0,r0,#0x10
00004c  4a26              LDR      r2,|L10.232|
00004e  7010              STRB     r0,[r2,#0]
;;;280    
;;;281    		/* Calculate the maximum acceptable priority group value for the number
;;;282    		of bits read back. */
;;;283    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
000050  2007              MOVS     r0,#7
000052  4a26              LDR      r2,|L10.236|
000054  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;284    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
000056  e009              B        |L10.108|
                  |L10.88|
;;;285    		{
;;;286    			ulMaxPRIGROUPValue--;
000058  4824              LDR      r0,|L10.236|
00005a  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
00005c  1e40              SUBS     r0,r0,#1
00005e  4a23              LDR      r2,|L10.236|
000060  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;287    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
000062  f89d0000          LDRB     r0,[sp,#0]
000066  0640              LSLS     r0,r0,#25
000068  0e00              LSRS     r0,r0,#24
00006a  9000              STR      r0,[sp,#0]
                  |L10.108|
00006c  f89d0000          LDRB     r0,[sp,#0]            ;284
000070  f0000080          AND      r0,r0,#0x80           ;284
000074  2880              CMP      r0,#0x80              ;284
000076  d0ef              BEQ      |L10.88|
;;;288    		}
;;;289    
;;;290    		#ifdef __NVIC_PRIO_BITS
;;;291    		{
;;;292    			/* Check the CMSIS configuration that defines the number of
;;;293    			priority bits matches the number of priority bits actually queried
;;;294    			from the hardware. */
;;;295    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
;;;296    		}
;;;297    		#endif
;;;298    
;;;299    		#ifdef configPRIO_BITS
;;;300    		{
;;;301    			/* Check the FreeRTOS configuration that defines the number of
;;;302    			priority bits matches the number of priority bits actually queried
;;;303    			from the hardware. */
;;;304    			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
000078  481c              LDR      r0,|L10.236|
00007a  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
00007c  f1c00007          RSB      r0,r0,#7
000080  2804              CMP      r0,#4
000082  d101              BNE      |L10.136|
000084  2001              MOVS     r0,#1
000086  e000              B        |L10.138|
                  |L10.136|
000088  2000              MOVS     r0,#0
                  |L10.138|
00008a  b950              CBNZ     r0,|L10.162|
00008c  bf00              NOP      
00008e  2010              MOVS     r0,#0x10
000090  f3808811          MSR      BASEPRI,r0
000094  f3bf8f4f          DSB      
000098  f3bf8f6f          ISB      
00009c  bf00              NOP      
00009e  bf00              NOP      
                  |L10.160|
0000a0  e7fe              B        |L10.160|
                  |L10.162|
;;;305    		}
;;;306    		#endif
;;;307    
;;;308    		/* Shift the priority group value back to its position within the AIRCR
;;;309    		register. */
;;;310    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
0000a2  4812              LDR      r0,|L10.236|
0000a4  6800              LDR      r0,[r0,#0]  ; ulMaxPRIGROUPValue
0000a6  0200              LSLS     r0,r0,#8
0000a8  4a10              LDR      r2,|L10.236|
0000aa  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;311    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
0000ac  4610              MOV      r0,r2
0000ae  8800              LDRH     r0,[r0,#0]  ; ulMaxPRIGROUPValue
0000b0  f40060e0          AND      r0,r0,#0x700
0000b4  6010              STR      r0,[r2,#0]  ; ulMaxPRIGROUPValue
;;;312    
;;;313    		/* Restore the clobbered interrupt priority register to its original
;;;314    		value. */
;;;315    		*pucFirstUserPriorityRegister = ulOriginalPriority;
0000b6  4a0b              LDR      r2,|L10.228|
0000b8  9801              LDR      r0,[sp,#4]
0000ba  7010              STRB     r0,[r2,#0]
;;;316    	}
;;;317    	#endif /* conifgASSERT_DEFINED */
;;;318    
;;;319    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;320    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
0000bc  480c              LDR      r0,|L10.240|
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4400070          ORR      r0,r0,#0xf00000
0000c4  490a              LDR      r1,|L10.240|
0000c6  6008              STR      r0,[r1,#0]
;;;321    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
0000c8  4608              MOV      r0,r1
0000ca  6800              LDR      r0,[r0,#0]
0000cc  f0404070          ORR      r0,r0,#0xf0000000
0000d0  6008              STR      r0,[r1,#0]
;;;322    
;;;323    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;324    	here already. */
;;;325    	vPortSetupTimerInterrupt();
0000d2  f7fffffe          BL       vPortSetupTimerInterrupt
;;;326    
;;;327    	/* Initialise the critical nesting count ready for the first task. */
;;;328    	uxCriticalNesting = 0;
0000d6  2000              MOVS     r0,#0
0000d8  4906              LDR      r1,|L10.244|
0000da  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;329    
;;;330    	/* Start the first task. */
;;;331    	prvStartFirstTask();
0000dc  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;332    
;;;333    	/* Should not get here! */
;;;334    	return 0;
0000e0  2000              MOVS     r0,#0
;;;335    }
0000e2  bd1c              POP      {r2-r4,pc}
;;;336    /*-----------------------------------------------------------*/
                          ENDP

                  |L10.228|
                          DCD      0xe000e400
                  |L10.232|
                          DCD      ucMaxSysCallPriority
                  |L10.236|
                          DCD      ulMaxPRIGROUPValue
                  |L10.240|
                          DCD      0xe000ed20
                  |L10.244|
                          DCD      uxCriticalNesting

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ulTimerCountsForOneTick
                          DCD      0x00000000
                  xMaximumPossibleSuppressedTicks
                          DCD      0x00000000
                  ulStoppedTimerCompensation
                          DCD      0x00000000
                  ucMaxSysCallPriority
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 208
|SVC_Handler| PROC
#line 209

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 225
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 226

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]

 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 374
|PendSV_Handler| PROC
#line 375

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #( 1 << (8 - 4) )
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 629
|vPortGetIPSR| PROC
#line 630

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
